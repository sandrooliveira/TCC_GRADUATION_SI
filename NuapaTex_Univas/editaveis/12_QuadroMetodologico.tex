\chapter{QUADRO METODOLÓGICO}
\par O quadro metodológico descreve os passos realizados para a 
execução do trabalho. Neste capítulo serão listados, em suas seções, os
itens essenciais no desenvolvimento do trabalho, sendo eles as técnicas, procedimentos, práticas e instrumentos
utilizados, o contexto de aplicação e o tipo de pesquisa.

\section{Tipo de pesquisa}

\par Para \citeonline[p.42]{pesquisa_social_gil}, a pesquisa tem um caráter
pragmático, é um “processo formal e sistemático de desenvolvimento do método científico. 
O objetivo fundamental da pesquisa é descobrir respostas para problemas mediante
o emprego de procedimentos científicos”.

\par Este trabalho terá como base a metodologia de pesquisa aplicada, pois
será desenvolvida uma aplicação inteligente utilizando Algoritmos Genéticos para
o auxílio na tomada de decisão sobre o processo de produção de calças de uma
confecção. Esta pesquisa consiste em procurar respostas para problemas propostos
baseados em padrões e conhecimentos já existentes.

\par \citeonline[p.35]{livro_metodos_de_pesquisa} afirmam que o método de
pesquisa aplicada, "objetiva gerar conhecimentos para aplicação prática, dirigidos a
solução de problemas específicos. Envolve verdades e interesses locais."  

\par Segundo \citeonline{livro_metodologia_de_estudo_de_pesquisa}, a pesquisa
aplicada tem como motivação básica a solução de problemas
concretos, práticos e operacionais e também pode ser chamada de pesquisa
empírica, pois o pesquisador precisa ir a campo, conversar com pessoas e
presenciar relações sociais.

\par Como citam \citeonline{tecnicas_de_pesquisa}, a pesquisa aplicada
caracteriza-se por possuir um interesse prático, quando os resultados serão aplicados ou utilizados na
solução de problemas que ocorrem na realidade, sempre visando gerar conhecimento
para solucionar situações específicas.

\par Como já foi explicado o tipo de pesquisa em que se enquadra este trabalho,
ela deve ser aplicada a um determinado contexto, conforme será explicado na
seção a seguir.

\section{Contexto de pesquisa}

\par Sabe-se que com a alta competitividade no mercado, as empresas, cada vez mais,
buscam diferenciais para seus produtos e, neste cenário, a ideia
de redução de custos se torna essencial, uma vez que tal redução pode ser
refletida no preço dos produtos permitindo que estes se diferenciem dos demais.
Dentre os fatores que viabilizam tais reduções está a otimização de processos que
consiste em organizar os procedimentos relacionados à produção de forma que
estes se tornem mais eficazes.

\par O software desenvolvido neste trabalho visa organizar uma linha de produção
de forma que esta se torne o mais eficiente possível. Será utilizada como
base uma fábrica de confecção de calças situada na cidade de
Cachoeira de Minas - MG, porém a base de conhecimento pode ser aplicada a outros
tipos de negócios que seguem o mesmo padrão de desenvolvimento de produtos.

\par Como cada funcionário trabalha em sua casa, é preciso ter uma boa
forma de distribuir o trabalho, permitindo que a produção possa ser feita em um
tempo menor e com custo reduzido.
Para isso, é necessário que o software faça a distribuição dos lotes a
serem confeccionados entre as costureiras de forma que estas sejam
alocadas de forma a receberem a quantidade de peças de acordo com sua
capacidade de trabalho, considerando também o tempo que cada costureira
irá gastar para pegar as peças e o material necessário para realizar seu
trabalho, além disso o software considera o preço cobrado por cada uma das
delas.

\par A aplicação cruza então todas estas informações de forma a se produzir
soluções para o problema e, no final, a melhor destas soluções será aquela 
que ofereça o menor custo e o menor tempo de produção. Porém, sabe-se que, 
em algoritmos genéticos, não há garantias que a solução encontrada é a melhor
para se resolver o problema mas a tendência é que a solução proposta pelo
algoritmo seja muito boa e seria muito difícil encontrá-la manualmente. 

\section{Instrumentos}

\par Segundo \citeonline{aula_joelma_26_03_15}, instrumentos de pesquisa são a
forma pela qual os dados são coletados para a realização do trabalho, podendo ser,
dentre outras, por meio de reuniões, questionários e entrevistas. Para
este trabalho foi utilizado os instrumentos descritos nas subseções a seguir.

\subsection{Entrevistas}
\par Segundo \citeonline{metodoliga_qualitativas_na_sociologia}, entrevista é
uma interação entre duas pessoas em que uma representa o entrevistador, 
que através de perguntas, obtêm informações por parte de outra pessoa que
representa o entrevistado.


% entrevista é um
% “processo de interação social entre duas pessoas na qual uma delas, o entrevistador,
% tem por objetivo a obtenção de informações por parte do outro, o entrevistado”



\par Foi realizada uma entrevista com o dono da empresa de confecção com o
objetivo de entender seu modelo de negócio para que então fosse possível começar
a fazer o levantamento dos requisitos do sistema. Para
\citeonline[p.128]{pressman2011engenharia}, levantamento de requisitos de
software consiste em

\begin{citacao}
``perguntar ao cliente, aos usuários e aos demais interessados quais são os
objetivos para o sistema ou produto, o que deve ser alcançado, como o sistema ou
produto atenda às necessidades da empresa e, por fim, como o sistema ou produto
deve ser utilizado no dia a dia''.
\end{citacao} 

\par A entrevista ocorreu no dia 09/05/2015 para conhecer mais sobre o processo de 
produção da fábrica. Nesta entrevista, ficou esclarecido todo processo e também
se teve acesso à forma como era controlada a distribuição da produção entre os funcionários. Toda
produção era controlada por meio de planilhas Excel, gerenciadas e alimentadas pelo proprietário. 
Tais planilhas contemplavam as estimativas de produção, as datas de entrega dos
lotes encomendados, levando em consideração a quantidade de peças por lote, o
corte e também o tempo que cada lote levaria para ser entregue.


\subsection{Reuniões}
\par De acordo com \citeonline{ref_reuniao}, reunião é o ajuntamento de
pessoas para se tratar de um determinado assunto em que é necessário que se
tenha conclusões sobre as questões que foram discutidas.

\par Durante o desenvolvimento do trabalho seriam realizadas várias reuniões
com o proprietário da fábrica de calças para sanar as dúvidas, sugestões e
outros assuntos que poderiam surgir. Todavia foi realizada apenas uma reunião com o proprietário
da empresa para poder entender como funciona o processo de produção, pois foi constatado nesta reunião que o
processo de produção havia sido alterado. No processo inicial, o qual foi a base
para este trabalho, cada funcionário trabalhava em sua residência e as peças eram distribuídas entre eles. Atualmente o processo
passou por muitas mudanças, uma delas é que a produção é feita em um lugar
apenas, sem a necessidade de transportar as peças entre as casas dos
funcionários. Segundo o proprietário isso gerou um ganho de tempo bem
expressivo, pois as peças circulavam dentro de um mesmo local e não pela cidade. 

\par Considerando essa mudança, não foram feitas outras reuniões com o
proprietário da fábrica, pois o trabalho não atende mais o processo de produção
atual da fábrica, porém o mesmo pode ser usado em outras empresas que seguem a
forma de produção pesquisada. Assim, foi definido um escopo para o desenvolvimento da aplicação baseando-se no 
processo inicial da fábrica de calças, que se resume em construir uma aplicação levando em consideração que:

\begin{itemize}
	
	\item o processo de desenvolvimento das calças deveria ser dividido em
	atividades com ordem de precedência;
	
	\item cada atividade poderia ser feita por uma ou mais costureiras, de acordo
	com a habilidade de cada uma;
	
	\item cada costureira gasta um tempo, medido em segundos, para fabricar uma
	peça;
	
	\item o usuário deveria ser capaz de cadastrar um novo processo, costureiras e
	habilidades;
	
	\item o total de peças deveria ser dividido em lotes e cada costureira deveria
	receber uma quantidade de lotes distribuídas aleatoriamente;
	
	\item o software deveria então oferecer como saída a melhor distribuição de
	forma a se produzir no menor tempo, considerando o tempo de produção de cada costureira e o transporte das peças entre elas.
	
\end{itemize}

\par A seção a seguir descreve como foi definido o escopo demonstrado acima.



\section{Procedimentos}

\par Esta seção descreve os procedimentos realizados na execução do trabalho,
definindo primeiramente o \textit{framework} de desenvolvimento e explicando
como o algoritmo genético foi desenvolvido para os requisitos definidos no escopo.

\par É importante ressaltar que a questão do custo ainda não foi implementada
até o presente momento, porém, como já temos implementada a estrutura de
distribuição, a adição do cálculo do custo se torna mais simples e será
apresentada na banca final.

\subsection{Framework de desenvolvimento}
\par Primeiramente é necessário ressaltar que, para o desenvolvimento da aplicação, foi utilizada uma base desenvolvida pelo professor Artur Barbosa durante as aulas de sistemas especialistas, do VII período do curso de sistemas de informação nesta universidade.
Esta base também denominada \textit{framework}, define regras a serem seguidas no desenvolvimento de cada elemento
de um algoritmo genético. Tal \textit{framework} é definido dentro da seguinte estrutura:

\begin{itemize}
	
	\item Classe \texttt{GAModel}:
	\par A classe \texttt{GAModel} é basicamente a classe mãe de todos os elementos de um algoritmo genético, 
	que representa o modelo que irá armazenar a população de indivíduos além de ser
	a classe que armazena os parâmetros que definem as configurações do algoritmo, tais como, tipo de cruzamento, tipo de mutação, 
	tamanho da população etc.
	
	\par A classe contém os seguintes atributos:
	
	\begin{itemize} 
		\item \textit{populationSize}:
		este atributo define qual será o tamanho da população, ou seja, quantos
		indivíduos irão formar cada população;
		
		\item \textit{generationQuantity}:
		como já explicado no quadro teórico, o processo de cruzamento e mutação se
		repete até que o número de indivíduos, definido no atributo anterior, seja atingido formando assim uma nova população e então, por sua vez, 
		este processo de geração de novas populações se repete até que seja atingido um número de gerações definido 
		pelo programador. Este atributo representa esta quantidade;
		
		\item \textit{elitism}:
		atributo do tipo \textit{boolean} que representa se o algoritmo vai ter a
		função de elitismo.
		Esta função, como já foi explicada no quadro teórico, quando está ativada (com
		valor \textit{true}), no momento de começar a se criar uma nova população os dois melhores indivíduos da população que será 
		substituída já começam a fazer parte da nova população, antes de começar o processo de cruzamento e mutação. 
		Este mecanismo garante que a nova população terá pelo menos dois indivíduos iguais ao da antiga população, o que irá 
		impedir que a nova população não seja pior que a anterior;
		
		\item \textit{foreignIndividualRate}:
		este atributo define a taxa de novos indivíduos que devem entrar em novas
		populações e será visto com mais detalhes na seção Indivíduos Estrangeiros.
		
		\item \textit{mutationRate}:
		como descrito no quadro teórico, a mutação é o fato de realizar pequenas
		alterações no indivíduo a fim de que este possa se tornar ainda melhor. Este parâmetro define uma porcentagem, geralmente baixa, que define quando 
		o indivíduo sofrerá mutação ou não. Esta questão ficará mais clara logo
		abaixo, quando será explicado o passo-a-passo da execução do algoritmo.
		
		\item \textit{mutationQuantity}:
		caso a mutação for ocorrer para o indivíduo, a alteração aleatória será feita
		nos cromossomos.
		Este parâmetro define quantos cromossomos do indivíduo deve ser alterado pela mutação;
		
		\item \textit{selectionType}:
		conforme descrito no quadro teórico, existem várias formas de seleção dos
		indivíduos para realizarem o cruzamento. Este parâmetro define qual será a forma escolhida pelo programador ao
		implementar o seu problema.No \textit{framework} este parâmetro é do tipo \texttt{enum} e pode assumir 2 valores o
		\textit{ROULETTE}, que define que o método de seleção utilizado será o de roleta e o \textit{CLASSIFICATION}, que 
		define que o método a ser utilizado é o de classificação. Neste projeto o
		método padrão que já foi pré-definido no código foi o método de roleta;
		
		\item \textit{crossType}:
		Assim como a seleção, existe diversas formas de fazer o cruzamento dos indivíduos. Este atributo, 
		também do tipo \texttt{enum} representa a forma de cruzamento e pode receber os valores \textit{Binary}, 
		\textit{Permutation}, \textit{Uniform} e \textit{Aritmetic}, esses valores
		definem qual implementação de cruzamento o algoritmo deve utilizar, esta aplicação
		utilizará o método \textit{Permutation}, desta forma somente um
		método de cruzamento foi implementado conforme mostra a seção Seleção,
		cruzamento e mutação;
		
		\item \textit{mutationType}:
		Segue a mesma forma que o selectionType e o crossType e pode assumir os valores \textit{Permutation}, 
		\textit{Binary} e \textit{Numerical}, e neste projeto foi o escolhido o
		método \textit{Permutation}.
		
	\end{itemize}
	
	\item Classe \texttt{Individual}:
	\par A classe abstrata \texttt{Individual} representa a estrutura básica de um indivíduo. 
	A classe contém uma \texttt{lista} do tipo 
	\texttt{Cromossomo}, que será descrita posteriormente, que contém uma coleção
	de objetos que representam as características da solução.
	
	\par A Classe contém ainda um atributo chamado \texttt{valor} que irá armazenar a qualidade, ou seja, qual é o custo
	da solução representada pelo indivíduo, tal valor é recebido no retorno da
	operação \texttt{calculateValue()} descrita abaixo.
	
	\par Com relação as operações, além dos \textit{getters and setters}, a classe contém a operação abstrata 
	\texttt{calculateValue()}, que realiza a função de avaliação, que mede a qualidade do indivíduo. Desta forma, ao utilizar este \textit{framework}, a classe que representa o indivíduo do 
	problema deve herdar desta classe  \texttt{Individual}. Fazendo isso, tal classe passará a ter uma lista de cromossomos 
	e o atributo que representa o seu valor e a classe obrigatoriamente terá que implementar a operação 
	\texttt{calculateValue()}, permitindo assim que o programador 
	desenvolva a função de avaliação específica para o seu problema.
	
	
	\item Classe \texttt{Chromosome}:
	\par É uma classe abstrata, que possui todos os métodos abstratos, desta forma
	ela só existe para garantir que os cromossomos do problema irão implementar os
	métodos necessários para o funcionamento do algoritmo. Estes métodos são:
	
	\begin{itemize}
		
		\item \texttt{equals}: necessário para efeito de comparação dos cromossomos;
		
		\item \texttt{doMutation}: realiza a mutação. Este deve
		ser implementado pela classe que representa o cromossomo, pois a
		mutação é feita nos cromossomos.
		
		\item \texttt{clone}: devolve um objeto exatamente com os mesmos
		atributos do objeto, porém em uma instância diferente.
		
	\end{itemize}
	
	
	\item Classe \texttt{IndividualPair}:
	\par A classe \texttt{IndvidualPair} possui uma estrutura simples. Apenas
	representa dois indivíduos. Ela se torna necessária, pois o processo de
	cruzamento dos indivíduos retornam dois novos indivíduos, desta forma, como 
	no Java não é possível retornar dois valores, é retornado então um objeto desta
	classe contendo os dois novos indivíduos criados. 
	
	
	\item Classe \texttt{GAController}:
	\par A classe \texttt{GAController}, como o próprio nome já diz, é o
	controlador de todo processo de execução do algoritmo genético.
	Ela recebe no seu construtor o modelo que é do tipo \texttt{GAModel}, que como
	já explicado anteriormente, armazena os parâmetros a serem seguidos na
	execução do algoritmo. Além disso, através do seu método principal
	denominado \texttt{execute()}, ela é responsável por criar novas populações, a
	partir de cruzamentos, mutações, elitismo, etc, tendo também a
	responsabilidade de chamar a função de classificação e avaliação de cada indivíduo.
	
	\par Os pontos a seguir descrevem basicamente os passos executados dentro do
	método execute(). Outros detalhes serão vistos mais adiante quando será
	descrita a implementação do algoritmo da fábrica de calças, pois será
	necessário realizar algumas adaptações neste \textit{framework}.
	
	\begin{itemize}
		\item	Criação da população inicial, através do método createInitialPopulation()
		do objeto que será extendido da classe GAModel;
		
		\item Classificação e avaliação da população inicial através do método
		\texttt{classify()};
		
		\item Realização do processo de elitismo, através do método
		\texttt{doElitism()};
		
		\item Inserção de indivíduos estrangeiros na população;
		
		\item Realização do processo de seleção de indivíduos, através do método
		\texttt{doSelection()};
		
		\item Execução do processo de cruzamento e mutação, através do método
		\texttt{doCrossing()} e \texttt{doMutaion()} respectivamente.
		
		
	\end{itemize}
	
	\par Após estes passos, uma nova população foi criada e está
	armazenada na variável newGeneration, assim o método
	\texttt{setPopulation()} do objeto \texttt{model} é chamado para então substituir
	a antiga população pela nova. Como a execução está dentro de uma estrutura de repetição
	\texttt{for}, ocorre um \texttt{loop} e então é recomeçado o processo de
	criação de uma outra população. Este processo para quando o número de gerações, 
	definido no parâmetro \texttt{generationQuantity} do objeto \texttt{model}
	for atingido, neste caso é dado o comando \texttt{break} e o \texttt{loop} é encerrado.
	% 	Para começar é chamado o método  \texttt{createInitialPopulation} da classe
	% 	\texttt{GAModel} para criar a população de indivíduos, este método será
	% 	implementado pela classe que irá herdar da classe \texttt{GAModel}.
	
	% 	\par Cada indivíduo representa uma solução para o problema, sua estrutura é
	% 	composta pela parte da calça a ser produzida, a costureira com
	% 	habilidade para produzir essa peça e o numero de lotes sorteados a ela.
	% 	Para explicar melhor precisa-se produzir um lote de 500 peças, será preciso
	% 	produzir 500 partes da frente, 500 partes de traz, etc., e assim
	% 	sucessivamente.
	% 	Esse lote de 500 peças é divdido entre os indivíduos da população. Para um
	% 	melhor entender a estrutura de um indivíduo veja a figura 5 a seguir:
	% 	
	% 	\begin{figure}[h!]
	% 	\centerline{\includegraphics[scale=0.5]{./imagens/individuos.png}}
	% 	\caption[Representação da estrura de um indivíduo]
	% 	{Representação da estrura de um indivíduo \textbf{Fonte:} Desenvolvido pelos autores}
	% 	\label{fig:exemplo1}
	% 	\end{figure} 
	
	
	
\end{itemize}

\par As próximas seções apresentam a implementação dos requisitos da aplicação
e dos elementos do algoritmo genético, seguindo as definições do \textit{framework}.

\subsection{Representação do processo de produção}

\par Primeiramente foi definido como seria o processo de fabricação. Este foi pensado com base no 
processo da fábrica, em que a confecção das peças deveria ser dividida em atividades que representam
cada parte da calça. Neste contexto, surgiu a necessidade de determinar uma ordem para a execução do processo, 
devido ao fato de que algumas atividades dependem da finalização de outras para poderem ser
realizadas. A Figura 4 demonstra basicamente um exemplo de ordem de execução do
processo de confecção.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.5]{./imagens/processo1.png}}
	\caption[Demonstração de um processo de fabricação]
	{Demonstração de um processo de fabricação \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}

\par  Uma questão importante que foi definida é que, independente da complexidade e tamanho do processo, este deve sempre começar 
com a atividade Carimbo e finalizar com a atividade Finalização. Isso ocorre pois a Finalização é sempre a última atividade 
de qualquer processo da fábrica e o Carimbo é uma atividade simbólica que representa o fato de o dono da fábrica separar o 
material de costura. O tempo e o custo gastos nesta separação não são contabilizados no algoritmo genético, somente o tempo de 
transporte dos materiais até as costureiras são considerados na distribuição, além disto esta atividade terá somente uma pessoa
trabalhando, que neste caso será o Marcelo, dono da fábrica.

\par Para armazenar este processo e suas atividades no software, foram utilizadas tabelas do banco de dados, conforme mostra 
a Figura 5.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/representacao_processo.png}}
	\caption[Representação do processo de fabricação no banco de dados]
	{Representação do processo de fabricação no banco de dados \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par A tabela \texttt{processo} tem como finalidade gerar um código único para representar 
cada processo de produção, cada processo representa um modelo, cada modelo
de calça possui um processo diferente que pode possuir diferentes atividades que
são representadas na tabela \texttt{atividade}, onde é feita a relação que define quais são as atividades de 
um processo,  além de conter quais são as habilidades necessárias para cada atividade, ou seja, cada registro desta 
tabela representa uma atividade do processo e qual habilidade é necessária para sua execução. O campo 
\texttt{is\_atividade\_inicial}, quando tem o valor 1, define que tal atividade
é a atividade Finalização. Este \textit{flag} é importante no momento de calcular o tempo total de execução do
processo e será visto com mais detalhes posteriormente e, por fim, a tabela
\texttt{atividade\_ordem} é onde é feita a definição de ordem de execução das
atividades.

\par A Figura 6 demonstra o mapeamento da relação entre a tabela
\texttt{atividade} e atividade\_ordem para o Java.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/atividade_diagram.png}}
	\caption[Classes Atividade e AtividadeOrdem]
	{Classes Atividade e AtividadeOrdem \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure} 

\par A classe Atividade pode ter zero ou vários objetos da classe
AtividadeOrdem.
Esta possui dois objetos da própria classe Atividade, um representando uma
atividade e outro representando a sua predecessora.

\par Considerando o processo de produção e o modelo de dados apresentados acima, foi
desenvolvido o algoritmo genético para a solução do problema. Conforme já demonstrado 
no Quadro Teórico, um algoritmo genético deve seguir uma ordem de execução conforme mostra
a Figura 7.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/algoritimos_geneticos.jpg}}
	\caption[Demonstração da execução de um AG]
	{Demonstração da execução de um AG \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\newpage


\par O primeiro passo para a execução do algoritmo então foi o desenvolvimento de uma lógica para a criação
da população inicial de indivíduos, conforme explicado na próxima seção.

\subsection {População inicial: Distribuição das atividades, Indivíduos e Cromossomos}
\par O processo de criação da população inicial assim como o processo de seleção, cruzamento e mutação e a chamada da 
função de avaliação de cada indivíduo, ocorre dentro da classe de controle do \textit{Framework}, ou seja, tal classe faz a 
orquestração de toda a execução do algoritmo genético e é denominada \texttt{GAController}.

\par A classe recebe em seu construtor um objeto de \texttt{GAModel} com as configurações do algoritmo, porém, como esta classe 
é abstrata, foi criado a classe \texttt{ProcessoModel} que herda de \texttt{GAModel}, passando a ter todos os atributos
da classe mãe. Para gerenciar então a execução do algoritmo foi criado uma classe de serviço denominada 
\texttt{GeneticAlgorithmManagement}, tal classe é instanciada pelo controlador da tela de distribuição de atividades, que será
explanado posteriormente, recebe, em seu método \texttt{iniciarDistribuicao}, os dados informados pelo 
usuário e inicia o algoritmo genético conforme mostra o Código 2.1.


\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Método \texttt{iniciarDistribuicao}. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	

public ProcessoIndividual iniciarDistribuicao(
			int numeroLote,BigDecimal prazEmSegundos,  
			int pecasPorLote,int idProcesso){

		EntityManager manager = ConFactory.getConn(); 
		
		ProcessoModel model = new ProcessoModel(manager,idProcesso);
		model.setNumeroLote(numeroLote);
		model.setPecasPorLote(pecasPorLote);
		model.setPrazoEmSegundos(prazEmSegundos);
		model.setGenerationQuantity(10000);
		model.setPopulationSize(80);
		model.setElitism(true);
		model.setSelectionType(GAModel.SelectionType.CLASSIFICATION);
		model.setCrossType(CrossType.PERMUTATION);
		model.setForeignIndividualRate(0.3f);
		model.setMutation(GAModel.MutationType.PERMUTATION);
		model.setMutationRate(0.05f);
		model.setMutationQuantity(1);

		GAController controller = new GAController(model);
		return (ProcessoIndividual) controller.execute();
}


\end{lstlisting}

\par Tal método retorna um objeto do tipo \texttt{ProcessoIndividual} para o controlador da tela de distribuição, este é o melhor indivíduo encontrado, ou seja, a melhor solução encontrada, isto será explicado com mais detalhes nas próximas seções assim como o significado de cada 
parâmetro do método \texttt{iniciarDistribuicao}. 

\par A classe \texttt{ProcessoModel} é a primeira a ser instanciada  e  recebe em seu construtor uma conexão para o 
banco de dados e o \texttt{ID} do processo a qual será executado o algoritmo. O construtor desta então chama o método
\texttt{getInformacoesCostureiras()} que tem por finalidade buscar no banco de dados todas as atividades do processo em questão, 
buscar todas as costureiras que tem a habilidade de fazer cada uma destas e criar um \texttt{HashMap} que possui como chave o 
\texttt{ID} da atividade e como valor uma lista de \texttt{CostureiraHabilidade}, feito isto o método também recupera  a 
atividade final (Finalização), conforme demonstra a Código 2.2.


\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Método \texttt{getInformacoesCostureiras}. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	

public void getInformacoesCostureiras() {
	List<CostureiraHabilidade> costureirasHabilidades = null;
	
	if (atividadesCostureiras != null && atividadesProcesso != null){
	   atividadesCostureiras.clear();
	   atividadesProcesso.clear();
	}
	
	atividadesCostureiras = 
	   new HashMap<Integer, List<CostureiraHabilidade>>();
	
	atividadesProcesso = 
	   atividadeDao.listAtividadesByProcesso(processo);
	
	/* Montar um MAP tendo como chave cada atividade do processo 
	   e a lista de costureiras que tenham a habilidade relacionada.*/
	for (Atividade atividade : atividadesProcesso) {
		
		costureirasHabilidades = 
		   cdao.getCostureirasByHabilidade
		      (atividade.getHabilidade().getIdHabilidade());
		
		atividadesCostureiras.put
		   (atividade.getIdAtividade(),costureirasHabilidades);
		
		if (atividade.isAtividadeFinal()) atividadeFinal = atividade;
	}
}

\end{lstlisting}

\par De acordo com o código 2.1, no objeto de \texttt{ProcessoModel} são definidas então as configurações do algoritmo genético, conforme explicado na seção \textit{Framework} de desenvolvimento, além disso, também são definidos no objeto os parâmetros recebidos do usuário. O parâmetro \texttt{numeroLote} define qual é o número de lotes a serem produzidos no processo, o \texttt{pecasPorLote} define quantas peças cada lote possui e o parâmetro \texttt{prazEmSegundos} indica qual é o prazo em segundos, considerando a data de início informada pelo usuário e a data de entrega do processo.

\par Então, após a definição dos parâmetros, é criado um novo objeto de \texttt{GAController} passando-se o 
objeto da classe \texttt{ProcessoModel} e logo o método \texttt{execute()} é chamado, dando-se início  a execução do
algoritmo genético. A primeira coisa a ser feita então é criar a população inicial de indivíduos que é criada a  partir do método \texttt{createInitialPopulation()} declarado de forma abstrata na classe \texttt{GAModel} e implementado pela classe 
\texttt{ProcessoModel}. Tal método basicamente executa um \texttt{for} de 0 até o tamanho da população (atributo 
\texttt{populationSize}) e assim para cada iteração é criado um objeto de \texttt{ProcessoIndividual} passando a 
\texttt{atividadeFinal}, o \texttt{map} que contém as atividades e suas costureiras (\texttt{atividadesCostureiras}) criados 
pelo método \texttt{getInformacoesCostureiras()}, além dos atributos \texttt{numeroLote}, \texttt{pecasPorLote} e
\texttt{prazoEmSegundos}, conforme mostra o código 2.3.


\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Método \texttt{createInitialPopulation}. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	

@Override
	public void createInitialPopulation() {
		for (int i = 0; i < getPopulationSize(); i++) {
			population.add
			   (new ProcessoIndividual
			       (atividadeFinal, prazoEmSegundos, atividadesCostureiras,
			        this.numeroLote, this.pecasPorLote));
	}
}

\end{lstlisting}

\par Quando se cria um novo indivíduo, a partir da instanciação de um novo objeto de \texttt{ProcessoIndividual},
acontece então a distribuição das atividades de forma a representar uma solução para o problema.
A realização desta distribuição foi realizada considerando que o total de
peças a ser produzido deveria ser dividido em lotes e então, em cada atividade,
este número de lote deveria ser distribuído entre as costureiras que possuíssem a habilidade em questão. Por exemplo: se a quantidade total de peças de uma ordem de produção for 500,
primeiramente deve-se definir qual será o número de peças por lote, neste caso, se for definido que cada lote  
deverá ter 50 peças, então o resultado final será 500/50 ou seja 10 lotes contendo 50 calças cada um. 

\par Neste sentido, seguindo o exemplo apresentado  na Figura 4, a distribuição
deverá ser feita de forma que para cada atividade do processo seja distribuído o trabalho de 10 lotes, ou seja, 10 lotes da parte da frente deve ser confeccionado e enviados para as costureiras que sabem colocar
o zíper e posteriormente estas enviam os 10 lotes para as costureiras que fazem finalização. Estas últimas irão depender
também de 10 lotes da parte de trás que também devem passar pelas costureiras que fazem a confecção dos bolsos. 


\par Com base nesses requisitos, um dos papeis desempenhados pelo algoritmo genético está na distribuição de
trabalho descrita acima. Inicialmente algoritmo irá distribuir, de forma
aleatória, o número de lotes definido entre as costureiras de cada atividade,
conforme mostra a Figura 7.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/distribuicao_exemplo.png}}
	\caption[Exemplo de distribuição aleatória de lotes para as costureiras]
	{Exemplo de distribuição aleatória de lotes para as costureiras \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par Uma costureira pode não receber lote (:0), isso permite que a decisão de
quem vai participar ou não também fique por conta do algoritmo. O exemplo demonstrado está considerando que se irá produzir 500 peças em lotes de 50, 
resultando assim em um total de 10 lotes.

\par Como já explanado no quadro teórico, a estrutura do algoritmo genético é composta
por populações que são formadas por indivíduos que por sua vez são formados por cromossomos.
Cada indivíduo representa uma solução e cada cromossomo do indivíduo representa uma de suas características. 
Assim, então, é gerada uma população inicial de indivíduos e, a partir desta, um
processo de cruzamento e mutação é iniciado a fim de que possam ser gerados
novos indivíduos que representem soluções ainda melhores que seus antecessores.

\par Neste sentido, para o desenvolvimento do algoritmo de distribuição de
lotes, o processo de definição de indivíduo e cromossomo foi o primeiro passo do desenvolvimento da aplicação. Isso se
deve ao fato de que estes elementos compõe a parte crucial para que se
possa definir a lógica a ser seguida para a definição da população inicial, o
tipo de cruzamento a função de avaliação, etc.

\par Neste caso, cada indivíduo da população irá representar uma forma de
distribuir as atividades e cada número de lotes distribuídos a determinada
costureira em uma determinada atividade irá representar um cromossomo. 
Tomando como base o exemplo da Figura 7, o quadro, como um todo, representa 
o indivíduo e cada distribuição, como por exemplo a Roberta, que recebeu 5 
lotes para confeccionar, representa um cromossomo.

\par Para fazer esta representação em Java, primeiramente foi criado uma classe denominada \texttt{ProcessoChromosome} que é
representada na Figura 8:

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.5]{./imagens/processo_chromosome_diagram.png}}
	\caption[Classe ProcessoChromosome]
	{Classe ProcessoChromosome \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}


\par A classe \texttt{ProcessoChromosome} herda de \texttt{Chromosome} do
\textit{framework} descrito na Figura 8. Por enquanto, é necessário compreender
apenas os atributos \texttt{atividade}, costureiraHabilidade e
\texttt{quantidade\_lotes}, que recebem seus valores pelo construtor, os
demais atributos e métodos são utilizados pela função de avaliação e serão explicados mais adiante. 
O atributo atividade é do tipo \texttt{int} e representa o \texttt{ID} da
atividade, no banco de dados, a qual se está atribuindo a costureira e a
quantidade de lotes, este atributo será passado na criação de cada cromossomo
sempre que for necessário se criar um novo indivíduo. O atributo \texttt{costureiraHabilidade} é do tipo CostureiraHabilidade, que representa o
mapeamento da tabela costureira\_habilidade do banco de dados, e faz a relação
entre quais habilidades cada costureira possui e quanto tempo cada uma gasta para fazer uma peça de 
uma determinada parte da calça, conforme demonstra a Figura 9.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/costureira_habilidade_tabela.png}}
	\caption[Armazenamento de dados das costureiras]
	{Armazenamento de dados das costureiras \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}


\par A classe \texttt{CostureiraHabilidade}, conforme ilustra a Figura 10, por
sua vez, possui o atributo habilidade, outro que
representa a costureira e um terceiro para representar o tempo que tal
costureira gasta para confeccionar uma peça com certa habilidade. Fez-se
necessário ter um atributo da classe CostureiraHabilidade ao invés de simplesmente ter um objeto do tipo Costureira, pois, 
na função de avaliação, como será visto mais adiante, necessita ter o tempo
que a costureira gasta para fazer a peça e este tempo pode variar para uma mesma costureira dependendo de suas habilidades.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/costureiraHabilidade_class.png}}
	\caption[Classe CostureiraHabilidade]
	{Classe CostureiraHabilidade \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par Assim, para representar cada característica da solução, tomando como
exemplo a Figura 7, o fato de Roberta fazer 5 lotes da parte da frente é representado na implementação
do código criando se um objeto da classe \texttt{ProcessoChromosome} passando no
construtor o \texttt{id} da atividade ``Frente'', um objeto de
\texttt{costureiraHabilidade}, cujo atributo \texttt{costureira} represente a
Marta, o atributo \texttt{habilidade} que representa a habilidade em questão e a
quantidade de lotes que Marta deverá confeccionar, que seria, neste caso, cinco.

\par A representação do indivíduo foi feita criando-se a classe \texttt{ProcessoIndividual} 
como demonstra a Figura 11:


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/class_individual.png}}
	\caption[Classe ProcessoIndividual]
	{Classe ProcessoIndividual \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par A classe \texttt{ProcessoIndividual} herda da classe \texttt{Individual} do
\textit{framework}, e por isso, esta passa a ter um \texttt{ArrayList} com
objetos do tipo \texttt{Chromosome}. Neste caso, como a classe \texttt{ProcessoChromosome} herda de \texttt{Chromosome} 
este \texttt{ArrayList} terá objetos do tipo \texttt{ProcessoChromosome}.

\par A criação dos cromossomos que irão compor o indivíduo é feita através do construtor da classe 
\texttt{ProcessoIndividual} e, é neste ponto, que os lotes são distribuídos para
cada atividade\_costureira.
O \texttt{construtor} da classe \texttt{ProcessoIndividual} recebe como
parâmetro um objeto representando a atividade final, que será utilizado pela função de avaliação mais adiante, e um \texttt{HashMap} que possui como chave o
\texttt{ID} de uma atividade e uma lista do  tipo \texttt{CostureiraHabilidade} contendo as costureiras e o tempo 
gasto por cada uma para fazer tal atividade.

\par Com base neste \texttt{HashMap} então é feita a criação dos cromossomos do indivíduo.
Em um primeiro momento, a distribuição de tarefas entre as costureiras seria feita em forma 
de porcentagem, ou seja, o algoritmo distribuiria uma porcentagem aleatória para cada costureira de 
uma determinada atividade, desta forma a distribuição seria feita da forma
demonstrada na ~\ref{list:distribuicaoPorcentagem}.

\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Criação de cromossomos (Primeira Abordagem). \textbf{Fonte:} Elaborado pelos autores.}}, label=list:distribuicaoPorcentagem] 	

	package edu.univas.edu.tcc.ga_code;
	
	import java.util.ArrayList;
	
	public class ProcessoIndividual extends Individual {
		
		public Atividade atividadeFinal;
		
		public ProcessoIndividual(Atividade atividadeInicial,
			Map<Integer, List<CostureiraHabilidade>> atividadesCostureiras){
		
			chromosomes = new ArrayList<Chromosome>();
			this.atividadeFinal = atividadeInicial;
			
			for(Integer key: atividadesCostureiras.keySet()){
			   for(CostureiraHabilidade costureira : 
				   atividadesCostureiras.get(key)){
				
				   Float porcentagem = (float) (Math.random() *1);
				   chromosomes.add(new ProcessoChromosome(key, 
					   costureira, porcentagem));
				}
			}
		}
	}

\end{lstlisting}
 
\par Feita a distribuição da porcentagem, antes de fazer o cálculo do indivíduo, seria então realizado 
um cálculo de normalização para que se pudesse encontrar o número de lotes a ser
produzido por cada costureira em cada atividade. Tomando como exemplo a Figura
13, este cálculo seria feito da seguinte forma:

\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.0]{./imagens/distribuicao_porcentagem.png}}
	\caption[Distribuição em porcentagem]
	{Distribuição em porcentagem \textbf{Fonte:} Desenvolvido pelos autores}
	\label{fig:exemplo1}
\end{figure}

\begin{itemize}
	\item Primeiramente deveria ser feito a soma de todas as porcentagens distribuídas, logo: 
	\par \texttt{0,53 + 0,44 + 0,29 = 1,26};
	
	\item o segundo passo seria calcular quanto cada porcentagem equivale dentro do total, neste 
	sentido o cálculo, já fazendo o arredondamento, seria: 
	\par \texttt{0,53 / 1,26 = 0,42 | 0,44 / 1,26 = 0,35 | 0,29 / 1,26 = 0,23}
	\par Logo, neste caso a Andrea seria responsável por 42\%, a Dita por 35\% e a Cida por 23\%;
	
	\item Assim, seria feito um cálculo com regra de 3 com o número total de peças. Supondo que o 
	 valor total fosse 500, logo:
	
	\par \texttt{(500 * 42) / 100 = 210 | (500 * 35) / 100 = 175 | (500 * 23) / 100 = 115}
	
	\par Neste caso então, a Andrea deveria produzir 210 peças, a Dita 175 e a Cida 115 peças;
	
	\item Por fim deveria ser feito uma divisão dos número de peças de cada costureira pela quantidade
     de peças por lote, que neste caso poderia ser 50, então realizando o cálculo já com arrendondamento:
     \par \texttt{210 / 50 = 4 | 175 / 50 = 4 | 115 / 50 = 2}
     
     \par Assim, a Andrea produziria 4 lotes, a Dita 4 e a Cida 2, dando o total
     dos 10 lotes a serem produzidos para a atividade de finalização.
	
\end{itemize}
 
 \par Os passos acima para distribuição de atividades seriam então repetidos
 para cada atividade chave do \texttt{HashMap} realizando tal distribuição para cada costureira da lista de 
 costureiras de cada atividade. No momento de fazer o último cálculo, foi feito
 um arredondamento, com isso se uma costureira tivesse tido uma porcentagem muito pequena, o valor de lotes para
 esta seria 0, eliminando-a assim da distribuição.
 
 \par Todavia verificou-se que, distribuindo desta forma, em alguns casos, o total de lotes por atividade não era distribuído
 de forma correta. Devido ao arredondamento, as vezes uma atividade ficava com lotes a menos ou lotes a mais do que o total
 definido, o que poderia causar erros no cálculo final. Além disso, no momento de definir como seria o cruzamento 
 surgiu uma questão importante que é o fato de que todas as vezes que fosse criado um indivíduo a partir de outros, deveria
 ser realizado o cálculo de normalização, e com isso a distribuição de lotes no novo indivíduo poderia ficar completamente
 diferente de seus pais, resultando assim na quebra do paradigma de algoritmos genéticos que descreve que os indivíduos filhos
 devem ser formados pela mesclagem das características dos pais. 


\par Buscou-se então uma outra alternativa para se realizar a distribuição dos lotes e definiu-se que, ao invés de distribuir
a porcentagem, a distribuição já deveria ser feita a nível de lote sendo esta também realizada de forma aleatória. Os parâmetros
do \texttt{construtor} da classe \texttt{ProcessoIndividuo} permaneceram da mesma forma, alternando somente a forma com que 
os lotes são distribuídos entre as costureiras em cada atividade conforme mostra
o Código ~\ref{fig:distribuicaoDiretamente}.


\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Distribuição em lotes diretamente. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:distribuicaoDiretamente] 	

public ProcessoIndividual(Atividade atividadeFinal,
	BigDecimal prazoEmSegundos, 
	Map<Integer, List<CostureiraHabilidade>> atividadesCostureiras, 
	int numeroLote, int pecasPorLote){
	
	chromosomes = new ArrayList<Chromosome>();
	Map<Integer, ProcessoChromosome> chromossomosMap = 
		new HashMap<Integer, ProcessoChromosome>();
	
	this.atividadeFinal = atividadeFinal;
	this.numeroLote = numeroLote;
	this.pecasPorLote = pecasPorLote;
	this.prazo = prazoEmSegundos;
	
	boolean distribuiuPorTodasCostureiras = false;
	
	int qtdeLote = 0;
	int cont = 0;
	
	for (Integer key : atividadesCostureiras.keySet()) {
		qtdeLote = numeroLote;
		cont = 0;
		int loteCostureira = 0;
		distribuiuPorTodasCostureiras = false;
		
		while (true){
			/* Verificou-se que quando a qtdeLote era 1 o valor
			   sorteado nunca era zero usando o Math.random com 
			   CAST para INT */
			if(qtdeLote == 1){
				loteCostureira  = Math.round((float) Math.random() * 1);
			}else{
				loteCostureira = (int) (Math.random() * qtdeLote);
			}
		
			CostureiraHabilidade costureiraHabilidade = 
				atividadesCostureiras.get(key).get(cont);
				
			ProcessoChromosome intermediario = 
				chromossomosMap.get(costureiraHabilidade.getIdCostureiraHabilidade());
				
			if(intermediario == null){
				ProcessoChromosome pc = new ProcessoChromosome
					(key, costureiraHabilidade,loteCostureira); 
					
				chromossomosMap.put
					(costureiraHabilidade.getIdCostureiraHabilidade(), pc);
					
				chromosomes.add(pc);
			}else{
				int oldValue = intermediario.getQuantidade_lotes();
				int newValue = oldValue + loteCostureira;
				intermediario.setQuantidade_lotes(newValue);
				intermediario.setLotesToShow(newValue);
			}
			
			if (cont == atividadesCostureiras.get(key).size() - 1) {
				cont = -1;
				distribuiuPorTodasCostureiras = true;
			} 
	
			qtdeLote -= loteCostureira;
			
			if(qtdeLote == 0 && distribuiuPorTodasCostureiras){
				break;
			}
			cont++;
		}
	}
}

\end{lstlisting}
 
\par Conforme descrito no Código 2.3, é feita uma iteração no
\texttt{HashMap} e, para cada atividade, é feita a distribuição dos lotes para
as costureiras desta lista. O algoritmo então atribui a cada costureira um valor
que pode variar de 0 até \texttt{qtdeLote}. Assim é criado objetos da classe \texttt{ProcessoChromosome} 
e colocado na lista de cromossomos do indivíduo. Após a criação de cada cromossomo, a quantidade de
lotes é subtraída pelo valor atribuído ao cromossomo recém criado.
Se a iteração passar por todas as costureiras da lista, o contador é reiniciado e então, se ao final sobrar 
lotes a serem distribuídos, a distribuição recomeça na primeira costureira, acrescentando assim seu 
número de lotes de acordo com o novo valor sorteado. A iteração termina quando não há mais lotes a serem 
distribuídos e a execução já passou por todas as costureiras. Em uma primeira versão, quando a execução chegava
ao final da lista de costureiras e ainda existiam lotes a serem distribuídos, este restante de lotes era atribuído
à última costureira, porém verificou-se, que desta forma, o algoritmo tendia a nunca distribuir zero lotes à última
costureira, o que causou resultados ineficazes na distribuição. Alterando para esta forma, a distribuição  passou a 
ser feita de maneira totalmente uniforme deixando o resultado coerente.
Como é possível perceber, neste processo uma costureira pode receber aleatoriamente o valor 0, o que irá resultar na 
sua eliminação do processo da mesma forma que iria ocorrer na primeira abordagem. Por fim, após a finalização do primeiro
\texttt{for} um novo indivíduo terá sido criado, semelhante ao quadro apresentado na Figura 7.

\par Concluindo, a distribuição das atividades ocorre todas as vezes que se cria um novo indivíduo.
Tais indivíduos podem ser criados no processo de criação da \texttt{população inicial}, na criação de 
\texttt{indivíduos estrangeiros} e no processo de \texttt{cruzamento}, como será descrito nas próximas seções,
ressaltando porém que no processo de cruzamento, os cromossomos do indivíduo é a mistura dos cromossomos dos pais,
já criados anteriormente, e portanto há também um construtor na classe \texttt{ProcessoIndividual} que recebe uma lista de 
cromossomos para se criar um novo indivíduo. Este processo será demonstrado na seção que descreve o cruzamento.


\subsection{Função de avaliação}

\par Após a criação da população inicial, esta é então submetida a um processo
de avaliação. Assim é feita uma iteração sobre a lista de indivíduos e para cada um é chamado então o seu método 
\texttt{calculateValue()}. Tal método é declarado de forma abstrata na classe mãe
\texttt{Individual} e implementado na classe \texttt{ProcessoIndividual}.

\par Assim como já foi visto anteriormente, cada costureira sabe fazer uma ou
mais partes da calça e gasta um determinado tempo, medido em segundos, além de cobrar um valor 
para se produzir cada peça, que varia de  acordo com a habilidade, além disto, existe um 
tempo de transporte entre cada costureira que é medido através da distância euclidiana, 
ou seja, cada costureira recebe um valor X e Y que representam suas localidades e então, 
através da formula euclidiana, é possível calcular a distância entre elas. A Figura 
~\ref{fig:demonstracao_costureiras_habilidades} demonstra os dados a serem considerados para o
cálculo do valor do indivíduo.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.5]{./imagens/tempo_habilidade_3.PNG}}
	\caption[Demonstração de costureiras e habilidades]
	{Demonstração de costureiras e habilidades \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:demonstracao_costureiras_habilidades}
\end{figure}

\par Com base nestes dados é realizado um cálculo a fim de se encontrar o tempo total de fabricação do número de peças
desejado e, ao fim, um valor de tempo e custo de produção será atribuído ao indivíduo, tais valores serão utilizados 
posteriormente no processo de classificação.

\par Para o desenvolvimento do cálculo do tempo de produção, foi necessário construir uma estrutura para representar a 
questão da ordem de precedência entre as atividades. Tal estrutura, conforme é demonstrado na Figura ~\ref{fig:montagem_node}, 
deveria ter nós representando cada atividade, as costureiras que trabalham em cada atividade e o número de lotes atribuídos a 
cada uma aleatoriamente pelo algoritmo.

%\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.0]{./imagens/montagem_node.png}}
	\caption[Estrutura de representação da ordem de precedência]
	{Estrutura de representação da ordem de precedência \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:montagem_node}
\end{figure}


\par Como foi visto na seção 1.4.2, cada indivíduo possui uma lista de
cromossomos, e cada cromossomo, por sua vez, representa a alocação de uma
costureira, contendo os lotes que esta deve produzir para uma determinada atividade.
Desta forma, para calcular o custo total de produção, foi realizada uma iteração 
na lista de cromossomos do indivíduo somando o preço total de confecção dos lotes
que cada costureira recebeu aleatoriamente pelo algoritmo conforme mostra o Código
~\ref{list:metodoCalculateValue}.

\par Para o cálculo do tempo de produção, definiu-se então que tal lista de cromossomos deveria ser
dividida de forma que se pudesse agrupar os cromossomos por atividade estabelecendo assim a relação 
demonstrada na Figura 16, para, que por fim, o cálculo pudesse ser realizado.
Para isso, conforme demonstrado no Código ~\ref{list:metodoCalculateValue}, primeiramente, a lista de 
cromossomos foi distribuída em um \texttt{HashMap} denominado \texttt{atividadeCromossomos}, contendo 
como chave a atividade e como valor a lista de cromossomos para a respectiva atividade e foi criado uma 
classe denominada \texttt{Node}, sendo esta a responsável por criar a estrutura mostrada na Figura 16.

\par O método \texttt{calculateValue()}, após agrupar os cromossomos por atividade, 
 instancia um objeto da classe \texttt{Node} passando a \texttt{atividadeFinal} e o número de 
 peças por lote recebidos na criação do indivíduo, conforme descrito na seção anterior, e o map 
 atividadeCromossomos conforme mostra a Código ~\ref{list:metodoCalculateValue}.


\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Método \texttt{calculateValue()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:metodoCalculateValue] 	

	public void calculateValue() {
		Map<Integer, List<Chromosome>> atividadeCromossomos 
			= new HashMap<Integer, List<Chromosome>>();
		
		Integer lastAtividade = null;
		float custoTotal = 0;
		int totalPecasAProduzir = 0;
		List<Chromosome> cromossomos = null;
		
		/*Calcular o custo total*/
		for(Chromosome chromosomeCusto : chromosomes){
			totalPecasAProduzir = 0;
			ProcessoChromosome processoChromossome = 
				(ProcessoChromosome) chromosomeCusto;
				
			totalPecasAProduzir = 
				processoChromossome.getLotesToShow() * this.pecasPorLote;
				
			custoTotal += totalPecasAProduzir * 
				processoChromossome.getCostureiraHabilidade()
					.getPrecoPorPeca();
		}
		
		for (Chromosome chromosome : chromosomes) {
		ProcessoChromosome processoChromossome = (ProcessoChromosome) chromosome;
		
			if (lastAtividade == null || lastAtividade != processoChromossome.getAtividade()) {
				cromossomos = new ArrayList<Chromosome>();
				
				atividadeCromossomos.put
					(processoChromossome.getAtividade(),cromossomos);
				lastAtividade = processoChromossome.getAtividade();
			}
			cromossomos.add(processoChromossome);
		}
		node = new Node(atividadeFinal, atividadeCromossomos,this.pecasPorLote);
		
		setCusto(custoTotal);
		
		
		/*So deve-se calcular o valor do individuo se 
		  ele nao foi calculado ainda porque uma vez calculado 
		  o valor o numero de lotes no objeto cromossomo foi 
		  decrementado */
		if (getValue() == 0) {
			setValue(node.getValorTotal());
			setRootNode(node);
		}
	}

\end{lstlisting}


\par A estrutura da classe \texttt{Node} foi realizada de forma a produzir objetos de si mesma de forma recursiva, assim 
cada vez que esta é instanciada, é como se criasse um nó daqueles
mostrados na Figura 16.Assim, quando o método \texttt{calculateValue()} instancia um objeto
\texttt{Node}, no construtor deste outros nós são criados, e então toda
estrutura, como foi ilustrada na Figura 16, será criada. O Código 2.6 mostra a construção de um objeto \texttt{Node}. 

\begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Construtor da classe Node. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	

	public Node(Atividade atividade,Map<Integer,List<Chromosome>>
		 atividadeCromossomos, int pecasPorLote){
		
		this.atividade = atividade;
		this.pecasPorLote = pecasPorLote;
		cromossomos = atividadeCromossomos.
			get(atividade.getIdAtividade());
			
		Atividade atividadePredecessora = null;
		
		for(AtividadeOrdem predecessora : 
			atividade.getAtividadeOrdemsForIdAtividade()){
			
			atividadePredecessora = 
				predecessora.getAtividadePredecessora();
		
			predecesoras.add(new Node(atividadePredecessora,
				atividadeCromossomos,pecasPorLote));
		}
	}
\end{lstlisting}

\par A classe \texttt{Node} recebe em seu construtor um objeto de Atividade, que na primeira vez que o objeto for instanciado
será a atividade final, o \texttt{MAP} com todos os cromossomos e o número de peças por lote, que será utilizado posteriormente.
O construtor então armazena as informações e pega do \texttt{MAP} somente os cromossomos relacionados a atividade recebida e, 
por fim, faz uma iteração na lista de atividades predecessoras da atividade recebida e, recursivamente, cria novos nós, 
construindo assim, a estrutura demonstrada na Figura 16.

\par Como se pode ver no método \texttt{calculateValue()} no Código 2.5, após
criar a estrutura de nós, é chamado o método \texttt{getValorTotal()} do objeto
\texttt{node} criado. Este método é responsável por iniciar a sequência lógica que 
faz o cálculo do tempo total a ser gasto pelo indivíduo, calculando o tempo gasto por 
cada costureira, definindo quem irá enviar peças pra quem e calculando o tempo de transporte 
de cada envio, conforme demonstra Código ~\ref{list:codigo_metodo_get_valor_total} .

\begin{lstlisting} [style=custom_Java,caption={[Método \texttt{getValorTotal()}]{Método \texttt{getValorTotal()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:codigo_metodo_get_valor_total] 	

	public long getValorTotal(){
		long valor =  0;
		long maior = 0;
		
		for(Chromosome chromosome : cromossomos){
			ProcessoChromosome processoChromosome = 
				(ProcessoChromosome) chromosome;
		
			if(processoChromosome.getQuantidade_lotes() > 0){
				valor = getCromossomeValue(processoChromosome,
					processoChromosome.getQuantidade_lotes());
			}
	
			if(valor > maior){
				maior = valor;
			}
		}
		return maior;
	}

\end{lstlisting}


\par O método faz uma iteração na lista de cromossomos do nó da atividade final e irá chamar o método getChromosomeValue passando 
cada cromossomo e o valor de seus lotes, e irá retornar o valor do maior cromossomo.

\par Tomando como base a Figura 17, para facilitar o entendimento, o método
getChromosomeValue() será chamado passando o cromossomo "Josi" e o inteiro 10 na quantidade de lotes. 
Este método é responsável por calcular o tempo gasto 
pela costureira para realizar os lotes atribuídos a ela. O tempo gasto pela
costureira é definido por \texttt{NLC * QPL * TP}, onde: \texttt{NLC} é o número
de lotes atribuídos para a costureira, \texttt{QPL} é a quantidade de peças por
lote e o \texttt{TP} é o tempo que a costureira gasta para fazer cada peça, 
porém este tempo também é influenciado pelo tempo que se é gasto para receber 
as partes dependentes, conforme demonstra o código ~\ref{list:codigo_metodo_get_cromossome_value}.


\begin{lstlisting} [style=custom_Java,caption={[Método \texttt{getValorTotal()}]{Método \texttt{getCromossomeValue()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:codigo_metodo_get_cromossome_value] 	

public long getCromossomeValue(ProcessoChromosome processoChromosome,
	int qtdeLote){
	
	long valor = 0;
	valor = qtdeLote * this.pecasPorLote *
		 processoChromosome.getCostureiraHabilidade().getTempoPorPeca();

	valor += getTempoRecebimentoPecas(processoChromosome,qtdeLote);
	return valor;
}

\end{lstlisting}

\par O método \texttt{getChromossomeValue()} chama então o método getTempoRecebimentoPecas(), passando o cromossomo Josi e 
o inteiro 10 como quantidade de lote. O método chamado tem a função de fazer uma busca nos nós predecessores buscando encontrar 
qual o tempo gasto para o recebimento das partes predecessoras da atividade e retornar o maior valor, 
conforme demonstra o Código ~\ref{list:codigo_metodo_get_recebimento_pecas}.

\begin{lstlisting} [style=custom_Java,caption={[Método \texttt{getValorTotal()}]{Método \texttt{getTempoRecebimentoPecas()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:codigo_metodo_get_recebimento_pecas] 	

	public long getTempoRecebimentoPecas(
		ProcessoChromosome processoChromosome, int qtdeLote){
		
		long valor = 0;
		long maior = 0;
		
		for(Node node : predecesoras){
			valor = node.getValueChromosomosPredecessores(
				processoChromosome, qtdeLote);
			
			if(valor > maior){
				maior = valor;
			}
		}
		return maior;
	}
}

\end{lstlisting}


\par Neste ponto começa então um processo recursivo, pois é chamado um método da
própria classe Node, só que de uma outra instância. O método chamado é o getValueChromosomosPredecessores() 
passando o cromossomo Josi e o inteiro 10, como número de lotes. O código ~\ref{list:codigo_metodo_getValueChromosomosPredecessores} 
mostra este método.


\begin{lstlisting} [style=custom_Java,caption={[Método \texttt{getValorTotal()}]{Método \texttt{getValueChromosomosPredecessores()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:codigo_metodo_getValueChromosomosPredecessores] 	

	public long getValueChromosomosPredecessores(
		ProcessoChromosome processoChromosome,int qtdeLote){
	
		int qtdeEachCromossome = 0;
		long valor = 0;
		long maior = 0;
		long distance = 0;
		
		for(Chromosome chromosome : cromossomos){
			ProcessoChromosome processoChromosomeBefore =
			   (ProcessoChromosome) chromosome;
			
			qtdeEachCromossome =
			   processoChromosomeBefore.getQtdeLotes(qtdeLote);
			
			if(qtdeEachCromossome > 0){
				qtdeLote -= qtdeEachCromossome;
				valor = getCromossomeValue(
					processoChromosomeBefore, qtdeEachCromossome);
					
				distance = calcularTempoEntreCostureiras(
					processoChromosome, processoChromosomeBefore);
				
				processoChromosome.addCostureiraPredecessora(
					processoChromosomeBefore.getCostureiraHabilidade(), 
					
				qtdeEachCromossome,distance,valor);
				
				valor += distance;
			}
			
			if(valor > maior){
				maior = valor;
			}
			
			if(qtdeLote == 0){
				break;
			}
		}
		return maior;
	}	
\end{lstlisting}

\par Tal método é responsável por iterar sobre a lista de cromossomos do nó anterior buscando de qual ou quais costureiras 
podem ser obtidos os lotes, retornando o maior valor. No exemplo da Figura ~\ref{fig:ex_solicitaca_lotes}, a atividade anterior é a ``Frente'' e a primeira costureira da lista é a Roberta, neste caso a Josi solicita 10 lotes da parte da frente para a Roberta, porém, 
neste caso, a Roberta confeccionou somente 5 lotes, neste caso , a Josi irá consumir os 5 lotes confeccionados.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.2]{./imagens/distribuicao_exemplo_apresentacao.png}}
	\caption[Exemplo de solicitação de lotes predecessores]
	{Exemplo de solicitação de lotes predecessores
	\textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:ex_solicitaca_lotes}
\end{figure}


\par Assim, a costureira Roberta é adicionada ao cromossomo Josi como costureira predecessora e novamente é chamado o método \texttt{getChromosomeValue()}, só que agora passando o cromossomo Roberta e a quantidade de lote que ela deve produzir para 
atender a Josi, para que se possa calcular o tempo, além disso será chamado o método calcularTempoEntreCostureiras() que irá 
retornar o tempo de transporte entre a Josi e a Roberta, e será somado ao valor retornado de \texttt{getChromosomeValue()} que  
foi chamado passando o cromossomo Roberta. O Código ~\ref{list:codigo_metodo_calcularTempoEntreCostureiras} demonstra este método \texttt{calcularTempoEntreCostureiras()}.



\begin{lstlisting} [style=custom_Java,caption={[Método \texttt{getValorTotal()}]{Método \texttt{getValueChromosomosPredecessores()}. \textbf{Fonte:} Elaborado pelos autores.}}, label=list:codigo_metodo_calcularTempoEntreCostureiras] 	

	public long calcularTempoEntreCostureiras(
		ProcessoChromosome processoChromosome,
		ProcessoChromosome processoChromosomeBefore){
		
		int posicaoCostureiraX = processoChromosome.
			getCostureiraHabilidade().
			getCostureira().getPositionX();
			
		int posicaoCostureiraY = processoChromosome.
			getCostureiraHabilidade().
			getCostureira().getPositionY();
		
		int posicaoCostureiraBeforeX = processoChromosomeBefore.
			getCostureiraHabilidade().
			getCostureira().getPositionX();
			
		int posicaoCostureiraBeforeY = processoChromosomeBefore.
			getCostureiraHabilidade().
			getCostureira().getPositionY();
		
		long distance = (long) Math.sqrt(
		Math.pow(posicaoCostureiraX - posicaoCostureiraBeforeX, 2)+
		Math.pow(posicaoCostureiraY - posicaoCostureiraBeforeY, 2));
		
		return distance * 100;
	}

\end{lstlisting}

\par Seguindo as execuções dos métodos já explicados, o fluxo de chamadas então será \texttt{getCromossomeValue()}, \texttt{getTempoRecebimentoPecas()}, getValueChromosomosPredecessores() e neste ponto o cromossomo Roberta irá solicitar 
para sua atividade anterior, 5 lotes, conforme mostra a Figura ~\ref{fig:ex_solicitaca_lotes}.

\par Neste caso, a atividade anterior é o Carimbo, neste ponto existe uma exceção, pois quando 
se solicita para atividade Carimbo, não são consumidos os lotes desta, pois, conforme definido 
no escopo explicado anteriormente, a atividade de Carimbo só possui o Marcelo como trabalhador e ele
apenas distribui o material de costura, assim qualquer solicitação feita a ele é correspondida, além 
disso como o tempo de produção e o custo por peça do Marcelo é zero, só sera considerado apenas
o tempo de transporte entre o Marcelo e a Roberta.

\par E assim, todo  o processo é feito recursivamente, na qual as costureiras
da primeira atividade vão consumindo os lotes das costureiras das atividades
predecessoras, conforme mostra a Figura ~\ref{fig:ex_solicitaca_lotes}.
Como a Roberta não conseguiu atender a Josi, uma vez calculado o tempo de produção ds 5 peças da Roberta, 
o algoritmo verifica a próxima costureira da atividade Frente, que seria a Tereza neste exemplo, e, da mesma forma, calcula
o tempo de produção do número de peças solicitadas que seria 5 neste caso.

\par Concluindo, o processo é todo feito recursivamente, na qual as costureiras das primeiras atividades vão consumindo
os lotes das costureiras das atividades predecessoras e somado o tempo de produção e o tempo de transporte entre elas, 
conforme mostra a Figura ~\ref{fig:ex_tempo_producao}. 


\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.2]{./imagens/distribuicao_tempo.png}}
	\caption[Distribuição demonstrando o tempo]
	{Distribuição demonstrando o tempo
		\textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:ex_tempo_producao}
\end{figure}

A recursividade para quando se chega na atividade Carimbo, então os valores começam a ser retornados.  No fim, prevalece sempre o 
maior valor e assim o método \texttt{getValorTotal()} irá retornar o tempo total de produção das partes e o transporte das mesmas 
entre as costureiras e então este valor é colocado no atributo \texttt{value} do indivíduo.

\subsection{Classificação dos indivíduos}

\subsection{Criação de uma nova população}
  Primeiro falar de indivíduos estrangeiros, seleção, cruzamento, mutação e atualização da população

\par O método \texttt{execute()} da classe \texttt{GAController} é responsável por coordenar toda execução do algoritmo.
     AQUI TENHO QUE EXPLICAR TODA A EXECUÇÃO DO ALGORITMO PASSANDO PELA SELEÇÃO, CRUZAMENTO, MUTAÇÃO E INDIVÍDUOS ESTRANGEIROS.

\par O conceito de indivíduos estrangeiros considera o fato de que, na natureza, durante o processo de geração de uma nova população, indivíduos estrangeiros podem começar a fazer parte de tal população. No algoritmo genético, tais indivíduos simplesmente são introduzidos
à nova população de acordo com uma taxa definida no atributo \texttt{foreignIndividualRate} da classe GAModel do \textit{framework}, 
conforme já explicado anteriormente, e os indivíduos são criados seguindo a mesma lógica utilizada para a criação da população inicial, 
a diferença é que, ao criar tais indivíduos, o \textit{looping} é executado de acordo com a taxa definida.


 
\subsection{Construção da interface gráfica, \texttt{CRUD} e apresentação dos dados} 
\par Este item já foi implementado porém ainda não documentado. 



% \label{cap:quadroMetodologico}
% 
% \par Conteúdo do quadro metodológico. Perceba a forma que se coloca uma palavra entre aspas: o \LaTeX~oferece muita ``facilitade de formatação''.
% 
% Exemplo de código Java:
% 
% \begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Métodos da classe \texttt{FilmeBean}. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	
% 	public FilmeBean(){  
%        //...
%    	}	
%    	
% 	public void saveMovie(){
% 		setListActorSelected();		
% 		if(this.movieDAO.saveMovieGraph(this.movieTo)){
% 			FacesContext.getCurrentInstance().addMessage(null, 
% 			   new FacesMessage("Filme cadastrado com sucesso!")); 
% 		}else{
% 			//...
% 		}		
% 		this.limpaCampos();
% 	}
% \end{lstlisting}
% 
% \par Agora será mostrado o exemplo do uso de fluxo de eventos apresentado no Quadro~\ref{quad:fluxo_evento_cadastro_filme}.
% 
% \begin{quadro}[h!]
%   \input{./fluxos/fluxo-evento-cadastro-filme}
%   \caption[Fluxo de eventos para cadastro de filme]
%            {Fluxo de eventos para cadastro de filme. \textbf{Fonte:} Elaborado pelos autores}
%   \label{quad:fluxo_evento_cadastro_filme}
% \end{quadro}
% 
% \par Outro exemplo é ilustrado na Figura~\ref{fig:bluesky}. Neste caso um código XML foi embutido dentro de um ambiente de figura, para que este código seja incluído no índice de figuras adequadamente.
%  
% \begin{figure}[ht!]
%   \begin{lstlisting} [style=custom_XML]
% 	...
% 	<context-param>
% 		<param-name>primefaces.THEME<\param-name>
% 		<param-value>bluesky<\param-value>
% 	<\context-param>
% 	...
%   \end{lstlisting}
%   \caption[Incluindo o tema \textit{BlueSky} ao contexto do projeto]
%           {Incluíndo o tema \textit{BlueSky} ao contexto do projeto. \textbf{Fonte:} Elaborado pelos autores.}
%   \label{fig:bluesky}
% \end{figure}
