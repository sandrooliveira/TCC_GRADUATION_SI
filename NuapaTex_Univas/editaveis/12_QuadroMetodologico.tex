\chapter{QUADRO METODOLÓGICO}
\par O quadro metodológico descreve os passos realizados para a 
execução do trabalho. Neste capítulo serão listados, em suas seções, os
itens essenciais no desenvolvimento do trabalho, sendo eles as técnicas, procedimentos, práticas e instrumentos
utilizados, o contexto de aplicação e o tipo de pesquisa.

\section{Tipo de pesquisa}

\par Para \citeonline[p.42]{pesquisa_social_gil}, a pesquisa tem um caráter
pragmático, é um “processo formal e sistemático de desenvolvimento do método científico. 
O objetivo fundamental da pesquisa é descobrir respostas para problemas mediante
o emprego de procedimentos científicos”.

\par Este trabalho terá como base a metodologia de pesquisa aplicada, pois
será desenvolvida uma aplicação inteligente utilizando Algoritmos Genéticos para
o auxílio na tomada de decisão sobre o processo de produção de calças de uma
confecção. Esta pesquisa consiste em procurar respostas para problemas propostos
baseados em padrões e conhecimentos já existentes.

\par \citeonline[p.35]{livro_metodos_de_pesquisa} afirmam que o método de
pesquisa aplicada, "objetiva gerar conhecimentos para aplicação prática, dirigidos a
solução de problemas específicos. Envolve verdades e interesses locais."  

\par Segundo \citeonline{livro_metodologia_de_estudo_de_pesquisa}, a pesquisa
aplicada tem como motivação básica a solução de problemas
concretos, práticos e operacionais e também pode ser chamada de pesquisa
empírica, pois o pesquisador precisa ir a campo, conversar com pessoas e
presenciar relações sociais.

\par Como citam \citeonline{tecnicas_de_pesquisa}, a pesquisa aplicada
caracteriza-se por possuir um interesse prático, quando os resultados serão aplicados ou utilizados na
solução de problemas que ocorrem na realidade, sempre visando gerar conhecimento
para solucionar situações específicas.

\par Como já foi explicado o tipo de pesquisa em que se enquadra este trabalho,
ela deve ser aplicada a um determinado contexto, conforme será explicado na
seção a seguir.

\section{Contexto de pesquisa}

\par Sabe-se que com a alta competitividade no mercado, as empresas, cada vez mais,
buscam diferenciais para seus produtos e, neste cenário, a ideia
de redução de custos se torna essencial, uma vez que tal redução pode ser
refletida no preço dos produtos permitindo que estes se diferenciem dos demais.
Dentre os fatores que viabilizam tais reduções está a otimização de processos que
consiste em organizar os procedimentos relacionados à produção de forma que
estes se tornem mais eficazes.

\par O software desenvolvido neste trabalho visa organizar uma linha de produção
de forma que esta se torne o mais eficiente possível. Será utilizada como
base uma fábrica de confecção de calças situada na cidade de
Cachoeira de Minas - MG, porém a base de conhecimento pode ser aplicada a outros
tipos de negócios que seguem o mesmo padrão de desenvolvimento de produtos.

\par Como cada funcionário trabalha em sua casa, é preciso ter uma boa
forma de distribuir o trabalho, permitindo que a produção possa ser feita em um
tempo menor e com custo reduzido.
Para isso, é necessário que o software faça a distribuição dos lotes a
serem confeccionados entre as costureiras de forma que estas sejam
alocadas de forma a receberem a quantidade de peças de acordo com sua
capacidade de trabalho, considerando também o tempo que cada costureira
irá gastar para pegar as peças e o material necessário para realizar seu
trabalho, além disso o software considera o preço cobrado por cada uma das
delas.

\par A aplicação cruza então todas estas informações de forma a se produzir
soluções para o problema e, no final, a melhor destas soluções será aquela 
que ofereça o menor custo e o menor tempo de produção. Porém, sabe-se que, 
em algoritmos genéticos, não há garantias que a solução encontrada é a melhor
para se resolver o problema mas a tendência é que a solução proposta pelo
algoritmo seja muito boa e seria muito difícil encontrá-la manualmente. 

\section{Instrumentos}

\par Segundo \citeonline{aula_joelma_26_03_15}, instrumentos de pesquisa são a
forma pela qual os dados são coletados para a realização do trabalho, podendo ser,
dentre outras, por meio de reuniões, questionários e entrevistas. Para
este trabalho foi utilizado os instrumentos descritos nas subseções a seguir.

\subsection{Entrevistas}
\par Segundo \citeonline{metodoliga_qualitativas_na_sociologia}, entrevista é
uma interação entre duas pessoas em que uma representa o entrevistador, 
que através de perguntas, obtêm informações por parte de outra pessoa que
representa o entrevistado.


% entrevista é um
% “processo de interação social entre duas pessoas na qual uma delas, o entrevistador,
% tem por objetivo a obtenção de informações por parte do outro, o entrevistado”



\par Foi realizada uma entrevista com o dono da empresa de confecção com o
objetivo de entender seu modelo de negócio para que então fosse possível começar
a fazer o levantamento dos requisitos do sistema. Para
\citeonline[p.128]{pressman2011engenharia}, levantamento de requisitos de
software consiste em

\begin{citacao}
``perguntar ao cliente, aos usuários e aos demais interessados quais são os
objetivos para o sistema ou produto, o que deve ser alcançado, como o sistema ou
produto atenda às necessidades da empresa e, por fim, como o sistema ou produto
deve ser utilizado no dia a dia''.
\end{citacao} 

\par A entrevista ocorreu no dia 09/05/2015 para conhecer mais sobre o processo de 
produção da fábrica. Nesta entrevista, ficou esclarecido todo processo e também
se teve acesso à forma como era controlada a distribuição da produção entre os funcionários. Toda
produção era controlada por meio de planilhas Excel, gerenciadas e alimentadas pelo proprietário. 
Tais planilhas contemplavam as estimativas de produção, as datas de entrega dos
lotes encomendados, levando em consideração a quantidade de peças por lote, o
corte e também o tempo que cada lote levaria para ser entregue.


\subsection{Reuniões}
\par De acordo com \citeonline{ref_reuniao}, reunião é o ajuntamento de
pessoas para se tratar de um determinado assunto em que é necessário que se
tenha conclusões sobre as questões que foram discutidas.

\par Durante o desenvolvimento do trabalho seriam realizadas várias reuniões
com o proprietário da fábrica de calças para sanar as dúvidas, sugestões e
outros assuntos que poderiam surgir. Todavia foi realizada apenas uma reunião com o proprietário
da empresa para poder entender como funciona o processo de produção, pois foi constatado nesta reunião que o
processo de produção havia sido alterado. No processo inicial, o qual foi a base
para este trabalho, cada funcionário trabalhava em sua residência e as peças eram distribuídas entre eles. Atualmente o processo
passou por muitas mudanças, uma delas é que a produção é feita em um lugar
apenas, sem a necessidade de transportar as peças entre as casas dos
funcionários. Segundo o proprietário isso gerou um ganho de tempo bem
expressivo, pois as peças circulavam dentro de um mesmo local e não pela cidade. 

\par Considerando essa mudança, não foram feitas outras reuniões com o
proprietário da fábrica, pois o trabalho não atende mais o processo de produção
atual da fábrica, porém o mesmo pode ser usado em outras empresas que seguem a
forma de produção pesquisada. Assim, foi definido um escopo para o desenvolvimento da aplicação baseando-se no 
processo inicial da fábrica de calças, que se resume em construir uma aplicação levando em consideração que:

\begin{itemize}
	
	\item o processo de desenvolvimento das calças deveria ser dividido em
	atividades com ordem de precedência;
	
	\item cada atividade poderia ser feita por uma ou mais costureiras, de acordo
	com a habilidade de cada uma;
	
	\item cada costureira gasta um tempo, medido em segundos, para fabricar uma
	peça;
	
	\item o usuário deveria ser capaz de cadastrar um novo processo, costureiras e
	habilidades;
	
	\item o total de peças deveria ser dividido em lotes e cada costureira deveria
	receber uma quantidade de lotes distribuídas aleatoriamente;
	
	\item o software deveria então oferecer como saída a melhor distribuição de
	forma a se produzir no menor tempo, considerando o tempo de produção de cada costureira e o transporte das peças entre elas.
	
\end{itemize}

\par A seção a seguir descreve como foi definido o escopo demonstrado acima.



\section{Procedimentos}

\par Esta seção descreve os procedimentos realizados na execução do trabalho,
definindo primeiramente o \textit{framework} de desenvolvimento e explicando
como o algoritmo genético foi desenvolvido para os requisitos definidos no escopo.

\par É importante ressaltar que a questão do custo ainda não foi implementada
até o presente momento, porém, como já temos implementada a estrutura de
distribuição, a adição do cálculo do custo se torna mais simples e será
apresentada na banca final.

\subsubsection{Framework de desenvolvimento}
\par Primeiramente é necessário ressaltar que, para o desenvolvimento da aplicação, foi utilizada uma base desenvolvida pelo professor Artur Barbosa durante as aulas de sistemas especialistas, do VII período do curso de sistemas de informação nesta universidade.
Esta base também denominada \textit{framework}, define regras a serem seguidas no desenvolvimento de cada elemento
de um algoritmo genético. Tal \textit{framework} é definido dentro da seguinte estrutura:

\begin{itemize}
	
	\item Classe \texttt{GAModel}:
	\par A classe \texttt{GAModel} é basicamente a classe mãe de todos os elementos de um algoritmo genético, 
	que representa o modelo que irá armazenar a população de indivíduos além de ser
	a classe que armazena os parâmetros que definem as configurações do algoritmo, tais como, tipo de cruzamento, tipo de mutação, 
	tamanho da população etc.
	
	\par A classe contém os seguintes atributos:
	
	\begin{itemize} 
		\item \textit{populationSize}:
		este atributo define qual será o tamanho da população, ou seja, quantos
		indivíduos irão formar cada população;
		
		\item \textit{generationQuantity}:
		como já explicado no quadro teórico, o processo de cruzamento e mutação se
		repete até que o número de indivíduos, definido no atributo anterior, seja atingido formando assim uma nova população e então, por sua vez, 
		este processo de geração de novas populações se repete até que seja atingido um número de gerações definido 
		pelo programador. Este atributo representa esta quantidade;
		
		\item \textit{elitism}:
		atributo do tipo \textit{boolean} que representa se o algoritmo vai ter a
		função de elitismo.
		Esta função, como já foi explicada no quadro teórico, quando está ativada (com
		valor \textit{true}), no momento de começar a se criar uma nova população os dois melhores indivíduos da população que será 
		substituída já começam a fazer parte da nova população, antes de começar o processo de cruzamento e mutação. 
		Este mecanismo garante que a nova população terá pelo menos dois indivíduos iguais ao da antiga população, o que irá 
		impedir que a nova população não seja pior que a anterior;
		
		\item \textit{foreignIndividualRate}:
		este atributo define a taxa de novos indivíduos que devem entrar em novas
		populações e será visto com mais detalhes na seção Indivíduos Estrangeiros.
		
		\item \textit{mutationRate}:
		como descrito no quadro teórico, a mutação é o fato de realizar pequenas
		alterações no indivíduo a fim de que este possa se tornar ainda melhor. Este parâmetro define uma porcentagem, geralmente baixa, que define quando 
		o indivíduo sofrerá mutação ou não. Esta questão ficará mais clara logo
		abaixo, quando será explicado o passo-a-passo da execução do algoritmo.
		
		\item \textit{mutationQuantity}:
		caso a mutação for ocorrer para o indivíduo, a alteração aleatória será feita
		nos cromossomos.
		Este parâmetro define quantos cromossomos do indivíduo deve ser alterado pela mutação;
		
		\item \textit{selectionType}:
		conforme descrito no quadro teórico, existem várias formas de seleção dos
		indivíduos para realizarem o cruzamento. Este parâmetro define qual será a forma escolhida pelo programador ao
		implementar o seu problema.No \textit{framework} este parâmetro é do tipo \texttt{enum} e pode assumir 2 valores o
		\textit{ROULETTE}, que define que o método de seleção utilizado será o de roleta e o \textit{CLASSIFICATION}, que 
		define que o método a ser utilizado é o de classificação. Neste projeto o
		método padrão que já foi pré-definido no código foi o método de roleta;
		
		\item \textit{crossType}:
		Assim como a seleção, existe diversas formas de fazer o cruzamento dos indivíduos. Este atributo, 
		também do tipo \texttt{enum} representa a forma de cruzamento e pode receber os valores \textit{Binary}, 
		\textit{Permutation}, \textit{Uniform} e \textit{Aritmetic}, esses valores
		definem qual implementação de cruzamento o algoritmo deve utilizar, esta aplicação
		utilizará o método \textit{Permutation}, desta forma somente um
		método de cruzamento foi implementado conforme mostra a seção Seleção,
		cruzamento e mutação;
		
		\item \textit{mutationType}:
		Segue a mesma forma que o selectionType e o crossType e pode assumir os valores \textit{Permutation}, 
		\textit{Binary} e \textit{Numerical}, e neste projeto foi o escolhido o
		método \textit{Permutation}.
		
	\end{itemize}
	
	\item Classe \texttt{Individual}:
	\par A classe abstrata \texttt{Individual} representa a estrutura básica de um indivíduo. 
	A classe contém uma \texttt{lista} do tipo 
	\texttt{Cromossomo}, que será descrita posteriormente, que contém uma coleção
	de objetos que representam as características da solução.
	
	\par A Classe contém ainda um atributo chamado \texttt{valor} que irá armazenar a qualidade, ou seja, qual é o custo
	da solução representada pelo indivíduo, tal valor é recebido no retorno da
	operação \texttt{calculateValue()} descrita abaixo.
	
	\par Com relação as operações, além dos \textit{getters and setters}, a classe contém a operação abstrata 
	\texttt{calculateValue()}, que realiza a função de avaliação, que mede a qualidade do indivíduo. Desta forma, ao utilizar este \textit{framework}, a classe que representa o indivíduo do 
	problema deve herdar desta classe  \texttt{Individual}. Fazendo isso, tal classe passará a ter uma lista de cromossomos 
	e o atributo que representa o seu valor e a classe obrigatoriamente terá que implementar a operação 
	\texttt{calculateValue()}, permitindo assim que o programador 
	desenvolva a função de avaliação específica para o seu problema.
	
	
	\item Classe \texttt{Chromosome}:
	\par É uma classe abstrata, que possui todos os métodos abstratos, desta forma
	ela só existe para garantir que os cromossomos do problema irão implementar os
	métodos necessários para o funcionamento do algoritmo. Estes métodos são:
	
	\begin{itemize}
		
		\item \texttt{equals}: necessário para efeito de comparação dos cromossomos;
		
		\item \texttt{doMutation}: realiza a mutação. Este deve
		ser implementado pela classe que representa o cromossomo, pois a
		mutação é feita nos cromossomos.
		
		\item \texttt{clone}: devolve um objeto exatamente com os mesmos
		atributos do objeto, porém em uma instância diferente.
		
	\end{itemize}
	
	
	\item Classe \texttt{IndividualPair}:
	\par A classe \texttt{IndvidualPair} possui uma estrutura simples. Apenas
	representa dois indivíduos. Ela se torna necessária, pois o processo de
	cruzamento dos indivíduos retornam dois novos indivíduos, desta forma, como 
	no Java não é possível retornar dois valores, é retornado então um objeto desta
	classe contendo os dois novos indivíduos criados. 
	
	
	\item Classe \texttt{GAController}:
	\par A classe \texttt{GAController}, como o próprio nome já diz, é o
	controlador de todo processo de execução do algoritmo genético.
	Ela recebe no seu construtor o modelo que é do tipo \texttt{GAModel}, que como
	já explicado anteriormente, armazena os parâmetros a serem seguidos na
	execução do algoritmo. Além disso, através do seu método principal
	denominado \texttt{execute()}, ela é responsável por criar novas populações, a
	partir de cruzamentos, mutações, elitismo, etc, tendo também a
	responsabilidade de chamar a função de classificação e avaliação de cada indivíduo.
	
	\par Os pontos a seguir descrevem basicamente os passos executados dentro do
	método execute(). Outros detalhes serão vistos mais adiante quando será
	descrita a implementação do algoritmo da fábrica de calças, pois será
	necessário realizar algumas adaptações neste \textit{framework}.
	
	\begin{itemize}
		\item	Criação da população inicial, através do método createInitialPopulation()
		do objeto que será extendido da classe GAModel;
		
		\item Classificação e avaliação da população inicial através do método
		\texttt{classify()};
		
		\item Realização do processo de elitismo, através do método
		\texttt{doElitism()};
		
		\item Inserção de indivíduos estrangeiros na população;
		
		\item Realização do processo de seleção de indivíduos, através do método
		\texttt{doSelection()};
		
		\item Execução do processo de cruzamento e mutação, através do método
		\texttt{doCrossing()} e \texttt{doMutaion()} respectivamente.
		
		
	\end{itemize}
	
	\par Após estes passos, uma nova população foi criada e está
	armazenada na variável newGeneration, assim o método
	\texttt{setPopulation()} do objeto \texttt{model} é chamado para então substituir
	a antiga população pela nova. Como a execução está dentro de uma estrutura de repetição
	\texttt{for}, ocorre um \texttt{loop} e então é recomeçado o processo de
	criação de uma outra população. Este processo para quando o número de gerações, 
	definido no parâmetro \texttt{generationQuantity} do objeto \texttt{model}
	for atingido, neste caso é dado o comando \texttt{break} e o \texttt{loop} é encerrado.
	% 	Para começar é chamado o método  \texttt{createInitialPopulation} da classe
	% 	\texttt{GAModel} para criar a população de indivíduos, este método será
	% 	implementado pela classe que irá herdar da classe \texttt{GAModel}.
	
	% 	\par Cada indivíduo representa uma solução para o problema, sua estrutura é
	% 	composta pela parte da calça a ser produzida, a costureira com
	% 	habilidade para produzir essa peça e o numero de lotes sorteados a ela.
	% 	Para explicar melhor precisa-se produzir um lote de 500 peças, será preciso
	% 	produzir 500 partes da frente, 500 partes de traz, etc., e assim
	% 	sucessivamente.
	% 	Esse lote de 500 peças é divdido entre os indivíduos da população. Para um
	% 	melhor entender a estrutura de um indivíduo veja a figura 5 a seguir:
	% 	
	% 	\begin{figure}[h!]
	% 	\centerline{\includegraphics[scale=0.5]{./imagens/individuos.png}}
	% 	\caption[Representação da estrura de um indivíduo]
	% 	{Representação da estrura de um indivíduo \textbf{Fonte:} Desenvolvido pelos autores}
	% 	\label{fig:exemplo1}
	% 	\end{figure} 
	
	
	
\end{itemize}

\par As próximas seções apresentam a implementação dos requisitos da aplicação
e dos elementos do algoritmo genético, seguindo as definições do \textit{framework}.

\subsection{Representação do processo de produção}

\par Primeiramente foi definido como seria o processo de fabricação. Este foi pensado com base no 
processo da fábrica, em que a confecção das peças deveria ser dividida em atividades que representam
cada parte da calça. Neste contexto, surgiu a necessidade de determinar uma ordem para a execução do processo, 
devido ao fato de que algumas atividades dependem da finalização de outras para poderem ser
realizadas. A Figura 4 demonstra basicamente um exemplo de ordem de execução do
processo de confecção.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/processo1.png}}
	\caption[Demonstração de um processo de fabricação]
	{Demonstração de um processo de fabricação \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}

\par Para armazenar este processo e suas atividades no software, foram
utilizadas tabelas do banco de dados, conforme mostra a Figura 5.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/representacao_processo.png}}
	\caption[Representação do processo de fabricação no banco de dados]
	{Representação do processo de fabricação no banco de dados \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par A tabela \texttt{processo} tem como finalidade gerar um código único para representar 
cada processo de produção, cada processo representa um modelo, cada modelo
de calça possui um processo diferente que pode possuir diferentes atividades que
são representadas na tabela \texttt{atividade}, onde é feita a relação que define quais são as atividades de 
um processo,  além de conter quais são as habilidades necessárias para cada atividade, ou seja, cada registro desta 
tabela representa uma atividade do processo e qual habilidade é necessária para sua execução. O campo 
\texttt{is\_atividade\_inicial}, quando tem o valor 1, define que tal atividade
é a última do processo, tomando como base a Figura 4, ela seria a atividade
``Finalização''. Este \textit{flag} é importante no momento de calcular o tempo total de execução do
processo e será visto com mais detalhes posteriormente e, por fim, a tabela
\texttt{atividade\_ordem} é onde é feita a definição de ordem de execução das
atividades.

\par A Figura 6 demonstra o mapeamento da relação entre a tabela
\texttt{atividade} e atividade\_ordem para o Java.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/atividade_diagram.png}}
	\caption[Classes Atividade e AtividadeOrdem]
	{Classes Atividade e AtividadeOrdem \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure} 

\par A classe Atividade pode ter zero ou vários objetos da classe
AtividadeOrdem.
Esta possui dois objetos da própria classe Atividade, um representando uma
atividade e outro representando a sua predecessora.

\subsection{Distribuição das atividades (Indivíduos e Cromossomos)}

\par Com relação à distribuição das atividades, foi definido que o total de
peças a ser produzido deveria ser dividido em lotes e então, em cada atividade,
este número de lote deveria ser distribuído entre as costureiras que possuíssem a habilidade em questão. Por exemplo: se a quantidade total de peças de uma ordem de produção for 500,
primeiramente deve-se definir qual será o número de peças por lote, neste caso, se for definido que cada lote  
deverá ter 50 peças, então o resultado final será 500/50 ou seja 10 lotes contendo 50 calças cada um. 

\par Neste sentido, seguindo o exemplo apresentado  na Figura 4, a distribuição
deverá ser feita de forma que para cada atividade do processo seja distribuído o trabalho de 10 lotes, ou seja, 10 lotes da parte da frente deve ser confeccionado e enviados para as costureiras que sabem colocar
o zíper e posteriormente estas enviam os 10 lotes para as costureiras que fazem finalização. Estas últimas irão depender
também de 10 lotes da parte de trás que também devem passar pelas costureiras que fazem a confecção dos bolsos. 


\par Com base nesses requisitos, um dos papeis desempenhados pelo algoritmo genético está na distribuição de
trabalho descrita acima. Inicialmente algoritmo irá distribuir, de forma
aleatória, o número de lotes definido entre as costureiras de cada atividade,
conforme mostra a Figura 7.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.0]{./imagens/distribuicao_exemplo.png}}
	\caption[Exemplo de distribuição aleatória de lotes para as costureiras]
	{Exemplo de distribuição aleatória de lotes para as costureiras \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par Uma costureira pode não receber lote (:0), isso permite que a decisão de
quem vai participar ou não também fique por conta do algoritmo. O exemplo demonstrado está considerando que se irá produzir 500 peças em lotes de 50, 
resultando assim em um total de 10 lotes.

\par Como já explanado no quadro teórico, a estrutura do algoritmo genético é composta
por populações que são formadas por indivíduos que por sua vez são formados por cromossomos.
Cada indivíduo representa uma solução e cada cromossomo do indivíduo representa uma de suas características. 
Assim, então, é gerada uma população inicial de indivíduos e, a partir desta, um
processo de cruzamento e mutação é iniciado a fim de que possam ser gerados
novos indivíduos que representem soluções ainda melhores que seus antecessores.

\par Neste sentido, para o desenvolvimento do algoritmo de distribuição de
lotes, o processo de definição de indivíduo e cromossomo foi o primeiro passo do desenvolvimento da aplicação. Isso se
deve ao fato de que estes elementos compõe a parte crucial para que se
possa definir a lógica a ser seguida para a definição da população inicial, o
tipo de cruzamento a função de avaliação, etc.

\par Neste caso, cada indivíduo da população irá representar uma forma de
distribuir as atividades e cada número de lotes distribuídos a determinada
costureira em uma determinada atividade irá representar um cromossomo. 
Tomando como base o exemplo da Figura 7, o quadro, como um todo, representa 
o indivíduo e cada distribuição, como por exemplo a Marta, que recebeu 5 
lotes para confeccionar, representa um cromossomo.

\par Para fazer esta representação em Java, primeiramente foi criado uma classe denominada \texttt{ProcessoChromosome} que é
representada na Figura 8:

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/processo_chromosome_diagram.png}}
	\caption[Classe ProcessoChromosome]
	{Classe ProcessoChromosome \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}


\par A classe \texttt{ProcessoChromosome} herda de \texttt{Chromosome} do
\textit{framework} descrito na Figura 8. Por enquanto, é necessário compreender
apenas os atributos \texttt{atividade}, costureiraHabilidade e
\texttt{quantidade\_lotes}, que recebem seus valores pelo construtor, os
demais atributos e métodos são utilizados pela função de avaliação e serão explicados mais adiante. 
O atributo atividade é do tipo \texttt{int} e representa o \texttt{ID} da
atividade, no banco de dados, a qual se está atribuindo a costureira e a
quantidade de lotes, este atributo será passado na criação de cada cromossomo
sempre que for necessário se criar um novo indivíduo. O atributo \texttt{costureiraHabilidade} é do tipo CostureiraHabilidade, que representa o
mapeamento da tabela costureira\_habilidade do banco de dados, e faz a relação
entre quais habilidades cada costureira possui e quanto tempo cada uma gasta para fazer uma peça de 
uma determinada parte da calça, conforme demonstra a Figura 9.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/costureira_habilidade_tabela.png}}
	\caption[Armazenamento de dados das costureiras]
	{Armazenamento de dados das costureiras \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}


\par A classe \texttt{CostureiraHabilidade}, conforme ilustra a Figura 10, por
sua vez, possui o atributo habilidade, outro que
representa a costureira e um terceiro para representar o tempo que tal
costureira gasta para confeccionar uma peça com certa habilidade. Fez-se
necessário ter um atributo da classe CostureiraHabilidade ao invés de simplesmente ter um objeto do tipo Costureira, pois, 
na função de avaliação, como será visto mais adiante, necessita ter o tempo
que a costureira gasta para fazer a peça e este tempo pode variar para uma mesma costureira dependendo de suas habilidades.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/costureiraHabilidade_class.png}}
	\caption[Classe CostureiraHabilidade]
	{Classe CostureiraHabilidade \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par Assim, para representar cada característica da solução, tomando como
exemplo a Figura 7, o fato de Marta fazer 5 lotes da parte da frente é representado na implementação
do código criando se um objeto da classe \texttt{ProcessoChromosome} passando no
construtor o \texttt{id} da atividade ``Frente'', um objeto de
\texttt{costureiraHabilidade}, cujo atributo \texttt{costureira} represente a
Marta, o atributo \texttt{habilidade} que representa a habilidade em questão e a
quantidade de lotes que Marta deverá confeccionar, que seria, neste caso, cinco.

\par A representação do indivíduo foi feita criando-se a classe \texttt{ProcessoIndividual} 
como demonstra a Figura 11:


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/class_individual.png}}
	\caption[Classe ProcessoIndividual]
	{Classe ProcessoIndividual \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par A classe \texttt{ProcessoIndividual} herda da classe \texttt{Individual} do
\textit{framework}, e por isso, esta passa a ter um \texttt{ArrayList} com
objetos do tipo \texttt{Chromosome}. Neste caso, como a classe \texttt{ProcessoChromosome} herda de \texttt{Chromosome} 
este \texttt{ArrayList} terá objetos do tipo \texttt{ProcessoChromosome}.

\par A criação dos cromossomos que irão compor o indivíduo é feita através do construtor da classe 
\texttt{ProcessoIndividual} e, é neste ponto, que os lotes são distribuídos para
cada atividade\_costureira.
O \texttt{construtor} da classe \texttt{ProcessoIndividual} recebe como
parâmetro um objeto representando a atividade final, que será utilizado pela função de avaliação mais adiante, e um \texttt{HashMap} que possui como chave o
\texttt{ID} de uma atividade e uma lista do  tipo \texttt{CostureiraHabilidade} contendo as costureiras e o tempo 
gasto por cada uma para fazer tal atividade.

\par Com base neste \texttt{HashMap} então é feita a criação dos cromossomos do indivíduo.
Em um primeiro momento, a distribuição de tarefas entre as costureiras seria feita em forma 
de porcentagem, ou seja, o algoritmo distribuiria uma porcentagem aleatória para cada costureira de 
uma determinada atividade, desta forma a distribuição seria feita da forma
demonstrada na Figura 12.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/tentativa_1_individual.png}}
	\caption[Criação de cromossomos (Primeira Abordagem)]
	{Criação de cromossomos (Primeira Abordagem) \textbf{Fonte:} Desenvolvido pelos autores}
	\label{fig:exemplo1}
\end{figure}
 
\par Feita a distribuição da porcentagem, antes de fazer o cálculo do indivíduo, seria então realizado 
um cálculo de normalização para que se pudesse encontrar o número de lotes a ser
produzido por cada costureira em cada atividade. Tomando como exemplo a Figura
13, este cálculo seria feito da seguinte forma:

\begin{figure}[h!]
	\centerline{\includegraphics[scale=1.0]{./imagens/distribuicao_porcentagem.png}}
	\caption[Distribuição em porcentagem]
	{Distribuição em porcentagem \textbf{Fonte:} Desenvolvido pelos autores}
	\label{fig:exemplo1}
\end{figure}

\begin{itemize}
	\item Primeiramente deveria ser feito a soma de todas as porcentagens distribuídas, logo: 
	\par \texttt{0,53 + 0,44 + 0,29 = 1,26};
	
	\item o segundo passo seria calcular quanto cada porcentagem equivale dentro do total, neste 
	sentido o cálculo, já fazendo o arredondamento, seria: 
	\par \texttt{0,53 / 1,26 = 0,42 | 0,44 / 1,26 = 0,35 | 0,29 / 1,26 = 0,23}
	\par Logo, neste caso a Andrea seria responsável por 42\%, a Dita por 35\% e a Cida por 23\%;
	
	\item Assim, seria feito um cálculo com regra de 3 com o número total de peças. Supondo que o 
	 valor total fosse 500, logo:
	
	\par \texttt{(500 * 42) / 100 = 210 | (500 * 35) / 100 = 175 | (500 * 23) / 100 = 115}
	
	\par Neste caso então, a Andrea deveria produzir 210 peças, a Dita 175 e a Cida 115 peças;
	
	\item Por fim deveria ser feito uma divisão dos número de peças de cada costureira pela quantidade
     de peças por lote, que neste caso poderia ser 50, então realizando o cálculo já com arrendondamento:
     \par \texttt{210 / 50 = 4 | 175 / 50 = 4 | 115 / 50 = 2}
     
     \par Assim, a Andrea produziria 4 lotes, a Dita 4 e a Cida 2, dando o total
     dos 10 lotes a serem produzidos para a atividade de finalização.
	
\end{itemize}
 
 \par Os passos acima para distribuição de atividades seriam então repetidos
 para cada atividade chave do \texttt{HashMap} realizando tal distribuição para cada costureira da lista de 
 costureiras de cada atividade. No momento de fazer o último cálculo, foi feito
 um arredondamento, com isso se uma costureira tivesse tido uma porcentagem muito pequena, o valor de lotes para
 esta seria 0, eliminando-a assim da distribuição.
 
 \par Todavia verificou-se que, distribuindo desta forma, em alguns casos, o total de lotes por atividade não era distribuído
 de forma correta. Devido ao arredondamento, as vezes uma atividade ficava com lotes a menos ou lotes a mais do que o total
 definido, o que poderia causar erros no cálculo final. Além disso, no momento de definir como seria o cruzamento 
 surgiu uma questão importante que é o fato de que todas as vezes que fosse criado um indivíduo a partir de outros, deveria
 ser realizado o cálculo de normalização, e com isso a distribuição de lotes no novo indivíduo poderia ficar completamente
 diferente de seus pais, resultando assim na quebra do paradigma de algoritmos genéticos que descreve que os indivíduos filhos
 devem ser formados pela mesclagem das características dos pais. 


\par Buscou-se então uma outra alternativa para se realizar a distribuição dos lotes e definiu-se que, ao invés de distribuir
a porcentagem, a distribuição já deveria ser feita a nível de lote sendo esta também realizada de forma aleatória. Os parâmetros
do \texttt{construtor} da classe \texttt{ProcessoIndividuo} permaneceram da mesma forma, alternando somente a forma com que 
os lotes são distribuídos entre as costureiras em cada atividade conforme mostra
a Figura 14.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/tentativa_2_individual.png}}
	\caption[Distribuição em lotes diretamente]
	{Distribuição em lotes diretamente \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\newpage
 
\par Conforme descrito na Figura 14, é feita uma iteração no
\texttt{HashMap} e, para cada atividade, é feita a distribuição dos lotes para
as costureiras desta lista. O algoritmo então atribui a cada costureira um valor
que pode variar de 0 até \texttt{qtdeLote}.
Assim é criado objetos da classe \texttt{ProcessoChromosome} e colocado na lista
de cromossomos do indivíduo. Após a criação de cada cromossomo, a quantidade de
lotes é subtraída pelo valor atribuído ao cromossomo recém criado.
Neste processo uma costureira pode receber aleatoriamente o valor 0, o que irá resultar na sua eliminação do processo da mesma forma
que iria ocorrer na primeira abordagem. Por fim, após a finalização do primeiro
\texttt{for} um novo indivíduo terá sido criado, semelhante ao quadro
apresentado na Figura 7.

\par Concluindo, a distribuição das atividades ocorre todas as vezes que se cria um novo indivíduo.
Como será explicado no próxima seção, indivíduos podem ser criados no processo
de criação da \texttt{população inicial}, na criação de \texttt{indivíduos estrangeiros} e no processo de \texttt{cruzamento}, ressaltando porém que no processo 
de cruzamento, os cromossomos do indivíduo é a mistura dos cromossomos dos pais,
já criados anteriormente, e portanto há também um construtor na classe \texttt{ProcessoIndividual} que recebe uma lista de cromossomos para se criar um novo indivíduo.
Este processo será demonstrado na seção que descreve o cruzamento.

\subsection {Classe modelo e População inicial}

\par Conforme visto na seção, a classe GAController é onde se inicia a execução do algoritmo e esta espera em seu 
construtor um objeto do tipo \texttt{GAModel}, porém, como esta classe é abstrata, foi criado a classe 
\texttt{ProcessoModel} que herda de \texttt{GAModel}, passando a ter todos os atributos
da classe mãe.

\par A classe \texttt{ProcessoModel} então é a primeira a ser instanciada pela classe principal e recebe em seu construtor
uma conexão para o banco de dados e o \texttt{ID} do processo a qual será
executado o algoritmo. O construtor então chama o método
\texttt{getInformacoesCostureiras()} que tem por finalidade buscar no banco de dados todas as atividades do 
processo em questão, buscar todas as costureiras que tem a habilidade de fazer
cada uma destas e criar um \texttt{HashMap} que possui como chave o \texttt{ID} da atividade e como valor uma 
lista de \texttt{CostureiraHabilidade}, feito isto o método 
também define qual é a atividade final do processo, conforme demonstra a Figura
15.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/metodo_informacoes_costureiras.png}}
	\caption[Método getInformacoesCostureiras()]
	{Método getInformacoesCostureiras() \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}



\par A classe principal então cria um novo objeto de \texttt{GAController} passando o objeto da classe \texttt{ProcessoModel} e
logo chama o método \texttt{execute()}, dando início então à execução do
algoritmo. A primeira coisa a ser feita então é criar a população inicial de indivíduos que é criada a 
partir do método \texttt{createInitialPopulation()} declarado de forma 
abstrata na classe \texttt{GAModel} e implementado pela classe \texttt{ProcessoModel}. Tal método basicamente executa um 
\texttt{for} de 0 até o tamanho da população (atributo \texttt{populationSize})
e assim para cada iteração é criado um objeto de \texttt{ProcessoIndividual} passando a \texttt{atividadeFinal} e o 
\texttt{map} que contém as atividades e suas costureiras
(\texttt{atividadesCostureiras}) criados pelo método \texttt{getInformacoesCostureiras()}.



\subsection{Função de avaliação}

\par Após a criação da população inicial, esta é então submetida a um processo
de avaliação. Assim é feita uma iteração sobre a lista de indivíduos e para cada um é chamado então o seu método 
\texttt{calculateValue()}. Tal método é declarado de forma abstrata na classe mãe
\texttt{Individual} e implementado na classe \texttt{ProcessoIndividual}.

\par Assim como já foi visto anteriormente, cada costureira sabe fazer uma ou
mais partes da calça e gasta um determinado tempo, medido em segundos, que varia de acordo com a habilidade, uma demonstração pode ser vista na 
Figura 16. Além disto, existe um tempo de transporte entre cada costureira,
porém, até a entrega do quadro metodológico, o armazenamento do tempo real de transporte entre as empregadas ainda não estava sendo armazenado no 
banco de dados e foi, portanto, gerado de forma aleatória, como será visto mais
adiante.

%\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.9]{./imagens/tempo_habilidade_3.PNG}}
	\caption[Demonstração de costureiras e habilidades]
	{Demonstração de costureiras e habilidades \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}

\par Com base nestas informações é realizado um cálculo a fim de se encontrar o tempo total de fabricação do número de peças
desejado levando em consideração o número de lotes atribuído a cada costureira, o tempo gasto por cada uma para se produzir e 
o tempo gasto com o transporte das partes entre elas, procurando assim encontrar
uma forma de distribuir o trabalho de forma a se produzir as peças desejadas no menor tempo possível. 

\par Para o desenvolvimento desta função, foi necessário construir uma estrutura para representar a questão da ordem de 
precedência entre as atividades. Tal estrutura, conforme é demonstrado na Figura
17, deveria ter nós representando cada atividade, as costureiras que trabalham
em cada atividade e o número de lotes atribuídos a cada uma aleatoriamente pelo algoritmo.

%\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/montagem_node.png}}
	\caption[Estrutura de representação da ordem de precedência]
	{Estrutura de representação da ordem de precedência \textbf{Fonte:}
	Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}


\par Como foi visto na seção 1.4.2, cada indivíduo possui uma lista de
cromossomos, e cada cromossomo, por sua vez, representa a alocação de uma
costureira, contendo os lotes que esta deve produzir para uma determinada atividade. 
Definiu-se então que tal lista de cromossomos deveria ser dividida de forma que se pudesse 
agrupar os cromossomos por atividade estabelecendo assim
a relação demonstrada na Figura 17, para, que por fim, o cálculo pudesse ser
realizado.

\par Para isso, primeiramente, a lista de cromossomos foi distribuída em um \texttt{HashMap} denominado 
\texttt{atividadeCromossomos}, contendo como chave a atividade e como valor a lista de cromossomos para a 
respectiva atividade e foi criado uma classe denominada \texttt{Node}, sendo
esta a responsável por criar a estrutura mostrada na Figura 17.

\par O Construtor da classe \texttt{Node} recebe um \texttt{map} e um objeto de
atividade. Primeiramente o método \texttt{calculateValue()} instancia um objeto da classe \texttt{Node} passando 
a \texttt{atividadeFinal} recebida por \texttt{ProcessoModel}, conforme descrito
na seção anterior, e o map atividadeCromossomos conforme mostra a Figura 18.

%\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/codigo_calculate_value.png}}
	\caption[Método calculateValue()]
	{Método calculateValue() \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par A estrutura da classe \texttt{Node} foi realizada de forma a produzir objetos de si mesma de forma recursiva, assim 
cada vez que esta é instanciada, é como se criasse um nó daqueles
mostrados na Figura 17.
Assim, quando o método \texttt{calculateValue()} instancia um objeto
\texttt{Node}, no construtor deste outros nós são criados, e então toda
estrutura, como foi ilustrada na Figura 17, será criada.
A Figura 19 mostra a construção de um objeto \texttt{Node}. 

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.8]{./imagens/node_class.png}}
	\caption[Construtor da classe Node]
	{Construtor da classe Node \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}


\par Como se pode ver no método \texttt{calculateValue()} na Figura 18, após
criar a estrutura de nós, é chamado o método \texttt{getValorTotal()} do objeto
\texttt{node} criado. Este método é responsável por iniciar a sequência lógica que faz o cálculo do tempo total a ser gasto pelo indivíduo, calculando o tempo gasto por cada costureira, definindo quem irá enviar
peças pra quem e calculando o tempo de transporte de cada envio, conforme
demonstra a Figura 20.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.7]{./imagens/metodo_getValorTotal.png}}
	\caption[Método getValorTotal()]
	{Método getValorTotal() \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par O método faz uma iteração na lista de cromossomos do nó da atividade final e irá chamar o método getChromosomeValue passando 
cada cromossomo e o valor de seus lotes, e irá retornar o valor do maior cromossomo.

\par Tomando como base a Figura 17, para facilitar o entendimento, o método
getChromosomeValue() será chamado passando o cromossomo "Josi" e o inteiro 2 na quantidade de lotes. Este método é responsável por calcular o tempo gasto 
pela costureira para realizar os lotes atribuídos a ela. O tempo gasto pela
costureira é definido por \texttt{NLC * QPL * TP}, onde: \texttt{NLC} é o número
de lotes atribuídos para a costureira, \texttt{QPL} é a quantidade de peças por
lote e o \texttt{TP} é o tempo que a costureira gasta para fazer cada peça, 
porém este tempo também é influenciado pelo tempo que se é gasto para receber 
as partes dependentes, conforme demonstra a Figura 21.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.8]{./imagens/metodo_getCromossomeValue.png}}
	\caption[Método getChromossomeValue()]
	{Método getChromossomeValue() \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\par O método \texttt{getChromossomeValue()} chama então o método getTempoRecebimentoPecas(), passando o cromossomo Josi e 
o inteiro 2 como quantidade de lote. O método chamado tem a função de fazer uma busca nos nós predecessores buscando encontrar 
qual o tempo gasto para o recebimento das partes predecessoras da atividade e retornar o maior valor, 
conforme demonstra a Figura 22.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.8]{./imagens/metodo_getTempoRecebimentoPecas.png}}
	\caption[Método getTempoRecebimentoPecas()]
	{Método getTempoRecebimentoPecas() \textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\newpage

\par Neste ponto começa então um processo recursivo, pois é chamado um método da
própria classe Node, só que de uma outra instância.
O método chamado é o getValueChromosomosPredecessores() passando o cromossomo
Josi e o inteiro 2, como número de lotes.
A Figura 23 mostra este método.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/metodo_getValueCrhomosomosPredecessores.png}}
	\caption[Método getValueCrhomosomosPredecessores()]
	{Método getValueCrhomosomosPredecessores() \textbf{Fonte:} Desenvolvido pelos
	autores.}
	\label{fig:exemplo1}
\end{figure}

\par Tal método é responsável por iterar sobre a lista de cromossomos do nó anterior buscando de qual ou quais costureiras 
podem ser obtidos os lotes, retornando o maior valor. No exemplo da Figura 24,
uma das atividades anteriores é o ``Ziper'' e a primeira costureira da lista é a Joana, 
neste caso serão consumidos dois lotes
da Joana.

\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/processo_solciitacao_de_lotes1.png}}
	\caption[Costureira Josi solicita dois lotes de atividades predecessoras]
	{Costureira Josi solicita dois lotes de atividades predecessoras
	\textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}


\par Assim, a costureira Joana é adicionada ao cromossomo Josi como costureira
predecessora e novamente é chamado o método \texttt{getChromosomeValue()}, só que agora passando o cromossomo 
Joana e a quantidade de lote que ela deve produzir para atender a Josi, para que
se possa calcular o tempo, além disso será chamado o método calcularTempoEntreCostureiras() que irá retornar o 
tempo de transporte entre a Josi e a Joana. Conforme explicado anteriormente, 
por enquanto este método retorna um tempo gerado aleatoriamente, e será somado
ao valor retornado de \texttt{getChromosomeValue()} que  foi chamado passando o cromossomo Joana.
Seguindo as execuções dos métodos já explicados, o fluxo de chamadas então será
\texttt{getCromossomeValue()}, \texttt{getTempoRecebimentoPecas()}, getValueChromosomosPredecessores() e 
neste ponto o cromossomo Joana irá solicitar para sua atividade anterior, 2
lotes, conforme mostra a Figura 25.


\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.5]{./imagens/processo_solciitacao_de_lotes2.png}}
	\caption[Costureira Joana solicita dois lotes de atividades predecessoras]
	{Costureira Joana solicita dois lotes de atividades predecessoras 
	\textbf{Fonte:} Desenvolvido pelos autores.}
	\label{fig:exemplo1}
\end{figure}

\newpage

\par Neste caso, será obtida uma peça da Cida e uma da Tereza, e será calculado,
o tempo de produção mais o tempo de transporte entre ambas e a Josi,
prevalecendo também o maior valor, além disso ambas são adicionadas ao
cromossomo Joana como costureiras predecessoras, para futuros relatórios e
testes.

\par Concluindo, o processo é todo feito recursivamente, na qual as costureiras
da primeira atividade vão consumindo os lotes das costureiras das atividades
predecessoras, conforme mostra a Figura 26.

%\newpage

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.6]{./imagens/processo_solciitacao_de_lotes3.png}}
	\caption[Costureiras consomem lotes de suas predecessoras]
	{Costureiras consomem lotes de suas predecessoras \textbf{Fonte:} Desenvolvido
	pelos autores.}
	\label{fig:exemplo1}
\end{figure}


A recursividade para quando se chega em uma atividade que não tem nós predecessores, então os valores começam a ser retornados. 
No fim, prevalece sempre o maior valor e assim o método \texttt{getValorTotal()} irá retornar o tempo total de 
produção das partes e o transporte das mesmas entre as costureiras e então este valor é colocado no atributo \texttt{value} do 
indivíduo.


\subsection{Indivíduos estrangeiros}
\par Este item já foi implementado porém ainda não documentado. 
  
\subsection{Seleção, Cruzamento e mutação}
\par Este item já foi implementado porém ainda não documentado.
 
\subsection{Construção da interface gráfica, \texttt{CRUD} e apresentação dos
dados} 
\par Este item já foi implementado porém ainda não documentado. 



% \label{cap:quadroMetodologico}
% 
% \par Conteúdo do quadro metodológico. Perceba a forma que se coloca uma palavra entre aspas: o \LaTeX~oferece muita ``facilitade de formatação''.
% 
% Exemplo de código Java:
% 
% \begin{lstlisting} [style=custom_Java,caption={[Métodos da classe \texttt{FilmeBean}]{Métodos da classe \texttt{FilmeBean}. \textbf{Fonte:} Elaborado pelos autores.}}, label=fig:metodosclassebean] 	
% 	public FilmeBean(){  
%        //...
%    	}	
%    	
% 	public void saveMovie(){
% 		setListActorSelected();		
% 		if(this.movieDAO.saveMovieGraph(this.movieTo)){
% 			FacesContext.getCurrentInstance().addMessage(null, 
% 			   new FacesMessage("Filme cadastrado com sucesso!")); 
% 		}else{
% 			//...
% 		}		
% 		this.limpaCampos();
% 	}
% \end{lstlisting}
% 
% \par Agora será mostrado o exemplo do uso de fluxo de eventos apresentado no Quadro~\ref{quad:fluxo_evento_cadastro_filme}.
% 
% \begin{quadro}[h!]
%   \input{./fluxos/fluxo-evento-cadastro-filme}
%   \caption[Fluxo de eventos para cadastro de filme]
%            {Fluxo de eventos para cadastro de filme. \textbf{Fonte:} Elaborado pelos autores}
%   \label{quad:fluxo_evento_cadastro_filme}
% \end{quadro}
% 
% \par Outro exemplo é ilustrado na Figura~\ref{fig:bluesky}. Neste caso um código XML foi embutido dentro de um ambiente de figura, para que este código seja incluído no índice de figuras adequadamente.
%  
% \begin{figure}[ht!]
%   \begin{lstlisting} [style=custom_XML]
% 	...
% 	<context-param>
% 		<param-name>primefaces.THEME<\param-name>
% 		<param-value>bluesky<\param-value>
% 	<\context-param>
% 	...
%   \end{lstlisting}
%   \caption[Incluindo o tema \textit{BlueSky} ao contexto do projeto]
%           {Incluíndo o tema \textit{BlueSky} ao contexto do projeto. \textbf{Fonte:} Elaborado pelos autores.}
%   \label{fig:bluesky}
% \end{figure}
